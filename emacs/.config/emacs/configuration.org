#+title: Emacs Configuration
#+author: Harry R. Schwartz
#+email: hello@harryrschwartz.com
#+options: toc:nil num:nil

* Configure =use-package=

I use =use-package= to install and configure my packages. My =init.el= includes the
initial setup for =package.el= and ensures that =use-package= is installed, since I
wanna do that right away.

This makes sure that =use-package= will install the package if it's not already
available. It also means that I should be able to open Emacs for the first time
on a fresh Debian box and have my whole environment automatically installed. I'm
not /totally/ sure about that, but we're gettin' close.

#+begin_src emacs-lisp
  (require 'use-package-ensure)
  (setq use-package-always-ensure t)
#+end_src

Always compile packages, and use the newest version available.

#+begin_src emacs-lisp
  (use-package auto-compile
    :config (auto-compile-on-load-mode))

  (setq load-prefer-newer t)
#+end_src

Disable deprecation warnings about =cl=. The =cl= library has been deprecated, but
lots of packages still use it. I can't control that, but I can disable the
warnings.

#+begin_src emacs-lisp
  (setq byte-compile-warnings '(cl-functions))
#+end_src

If an Emacs package relies on the installation of a system package, install that
package (for example, =deadgrep= doesn't work if =ripgrep= isn't installed). This
uses the system package manager (Debian's =apt=, in my case).

#+begin_src emacs-lisp
  (use-package use-package-ensure-system-package)
#+end_src

* Use =sensible-defaults.el=

Use [[https://github.com/hrs/sensible-defaults.el][sensible-defaults.el]] for some basic settings.

#+begin_src emacs-lisp
  (add-to-list 'load-path "~/code/personal/sensible-defaults.el")
  (require 'sensible-defaults)

  (sensible-defaults/use-all-settings)
  (sensible-defaults/use-all-keybindings)
  (sensible-defaults/backup-to-temp-directory)
#+end_src

* Set personal information

** Who am I? Where am I?

#+begin_src emacs-lisp
  (setq user-full-name "Harry R. Schwartz"
        user-mail-address "hello@harryrschwartz.com"
        calendar-latitude 49.26
        calendar-longitude -123.11
        calendar-location-name "Vancouver, BC")
#+end_src

* =evil-mode=

Load and configure =evil-mode=.

I'd prefer not to expand abbrevs when I hit escape. That's always jarring and
usually not what I want. In particular, it makes working with Coq really
frustrating.

Don't automatically load Evil bindings in different modes.

#+begin_src emacs-lisp
  (use-package evil
    :init
    (setq evil-want-abbrev-expand-on-insert-exit nil
          evil-want-keybinding nil)

    :config
    (evil-mode 1)
    (evil-define-key 'normal org-mode-map (kbd "TAB") 'org-cycle)
    (fset 'evil-visual-update-x-selection 'ignore))
#+end_src

Install =evil-collection=, which provides evil-friendly bindings for many modes.

#+begin_src emacs-lisp
  (use-package evil-collection
    :after evil
    :config
    (setq evil-collection-mode-list
          '(deadgrep
            dired
            elfeed
            ibuffer
            magit
            mu4e
            pdf-view
            which-key))

    (evil-collection-init))
#+end_src

Enable =surround= everywhere.

#+begin_src emacs-lisp
  (use-package evil-surround
    :config
    (global-evil-surround-mode 1))
#+end_src

Use =evil= with Org agendas.

#+begin_src emacs-lisp
  (use-package evil-org
    :after org
    :config
    (require 'evil-org-agenda)
    (evil-org-agenda-set-keys))
#+end_src

* Utility functions

Define a big ol' bunch of handy utility functions.

#+begin_src emacs-lisp
  (defun hrs/visit-last-migration ()
    "Open the most recent Rails migration. Relies on projectile."
    (interactive)
    (let ((migrations
           (directory-files
            (expand-file-name "db/migrate" (projectile-project-root)) t)))
      (find-file (car (last migrations)))))

  (defun hrs/find-file-as-sudo ()
    (interactive)
    (let ((file-name (buffer-file-name)))
      (when file-name
        (find-alternate-file (concat "/sudo::" file-name)))))

  (defun hrs/append-to-path (path)
    "Add a path both to the $PATH variable and to Emacs' exec-path."
    (setenv "PATH" (concat (getenv "PATH") ":" path))
    (add-to-list 'exec-path path))

  (defun hrs/image-path-p (path)
    "Return true if the path corresponds to an image file."
    (member (downcase (or (file-name-extension path) ""))
            '("bmp" "gif" "jpeg" "jpg" "png" "tiff")))
#+end_src

* UI preferences

** Tweak window chrome

I don't usually use the menu or scroll bar, and they take up useful space.

#+begin_src emacs-lisp
  (tool-bar-mode 0)
  (menu-bar-mode 0)
  (scroll-bar-mode -1)
#+end_src

There's a tiny scroll bar that appears in the minibuffer window. This disables
that:

#+begin_src emacs-lisp
  (set-window-scroll-bars (minibuffer-window) nil nil)
#+end_src

The default frame title isn't useful. This binds it to the name of the current
project:

#+begin_src emacs-lisp
  (setq frame-title-format '((:eval (projectile-project-name))))
#+end_src

** Use fancy lambdas

Why not?

#+begin_src emacs-lisp
  (global-prettify-symbols-mode t)
#+end_src

** Load up a theme

This sets up the current theme.

#+begin_src emacs-lisp
  (use-package spacemacs-theme
    :defer t
    :init
    (setq spacemacs-theme-org-bold nil
          spacemacs-theme-org-height nil)
    :config
    (load-theme 'spacemacs-light t))

  (load-theme 'spacemacs-light t)
#+end_src

If this code is being evaluated by =emacs --daemon=, ensure that each subsequent
frame is themed appropriately.

I've usually got a scenic wallpaper, so just a hint of transparency looks lovely
and isn't distracting or hard to read.

#+begin_src emacs-lisp
  (defun transparency (value)
    "Sets the transparency of the frame window. 0=transparent/100=opaque."
    (interactive "nTransparency Value 0 - 100 opaque:")
    (set-frame-parameter (selected-frame) 'alpha value))

  (when (daemonp)
    (load-theme 'spacemacs-light t)
    (add-hook 'after-make-frame-functions
              (lambda (frame)
                (with-selected-frame frame
                  (if (display-graphic-p)
                      (transparency 95)
                    (set-face-background 'default "unspecified-bg" (selected-frame)))))))
#+end_src

** Use =minions= to hide all minor modes

I never want to see a minor mode, and manually adding =:diminish= to every
use-package declaration is a hassle. This uses =minions= to hide all the minor
modes in the modeline. Nice!

#+begin_src emacs-lisp
  (use-package minions
    :config
    (setq minions-mode-line-lighter "⚙"
          minions-mode-line-delimiters (cons "" ""))
    (minions-mode 1))
#+end_src

** Configure a pretty modeline

#+begin_src emacs-lisp
  (use-package moody
    :config
    (setq x-underline-at-descent-line t)
    (moody-replace-mode-line-buffer-identification)
    (moody-replace-vc-mode))
#+end_src

** Scroll conservatively

When point goes outside the window, Emacs usually recenters the buffer point.
I'm not crazy about that. This changes scrolling behavior to only scroll as far
as point goes.

#+begin_src emacs-lisp
  (setq scroll-conservatively 100)
#+end_src

** Set default font and configure font resizing

I'm partial to Inconsolata for code and Adobe Garamond Pro for prose.

The standard =text-scale-= functions just resize the text in the current buffer;
I'd generally like to resize the text in /every/ buffer, and I usually want to
change the size of the modeline, too (this is especially helpful when
presenting). These functions and bindings let me resize everything all together!

Note that this overrides the default font-related keybindings from
=sensible-defaults=.

#+begin_src emacs-lisp
  (custom-set-faces
   '(italic ((t (:slant italic)))))

  (setq hrs/default-fixed-font "Inconsolata")
  (setq hrs/default-fixed-font-size 70)
  (setq hrs/current-fixed-font-size hrs/default-fixed-font-size)
  (set-face-attribute 'default nil
                      :family hrs/default-fixed-font
                      :height hrs/current-fixed-font-size)
  (set-face-attribute 'fixed-pitch nil
                      :family hrs/default-fixed-font
                      :height hrs/current-fixed-font-size)

  (setq hrs/default-variable-font "Adobe Garamond Pro")
  (setq hrs/default-variable-font-size 80)
  (setq hrs/current-variable-font-size hrs/default-variable-font-size)
  (set-face-attribute 'variable-pitch nil
                      :family hrs/default-variable-font
                      :height hrs/current-variable-font-size)

  (setq hrs/font-change-increment 1.1)

  (defun hrs/set-font-size ()
    "Change default, fixed-pitch, and variable-pitch font sizes to match respective variables."
    (set-face-attribute 'default nil
                        :height hrs/current-fixed-font-size)
    (set-face-attribute 'fixed-pitch nil
                        :height hrs/current-fixed-font-size)
    (set-face-attribute 'variable-pitch nil
                        :height hrs/current-variable-font-size))

  (defun hrs/reset-font-size ()
    "Revert font sizes back to defaults."
    (interactive)
    (setq hrs/current-fixed-font-size hrs/default-fixed-font-size)
    (setq hrs/current-variable-font-size hrs/default-variable-font-size)
    (hrs/set-font-size))

  (defun hrs/increase-font-size ()
    "Increase current font sizes by a factor of `hrs/font-change-increment'."
    (interactive)
    (setq hrs/current-fixed-font-size
          (ceiling (* hrs/current-fixed-font-size hrs/font-change-increment)))
    (setq hrs/current-variable-font-size
          (ceiling (* hrs/current-variable-font-size hrs/font-change-increment)))
    (hrs/set-font-size))

  (defun hrs/decrease-font-size ()
    "Decrease current font sizes by a factor of `hrs/font-change-increment', down to a minimum size of 1."
    (interactive)
    (setq hrs/current-fixed-font-size
          (max 1
               (floor (/ hrs/current-fixed-font-size hrs/font-change-increment))))
    (setq hrs/current-variable-font-size
          (max 1
               (floor (/ hrs/current-variable-font-size hrs/font-change-increment))))
    (hrs/set-font-size))

  (define-key global-map (kbd "C-)") 'hrs/reset-font-size)
  (define-key global-map (kbd "C-+") 'hrs/increase-font-size)
  (define-key global-map (kbd "C-=") 'hrs/increase-font-size)
  (define-key global-map (kbd "C-_") 'hrs/decrease-font-size)
  (define-key global-map (kbd "C--") 'hrs/decrease-font-size)

  (hrs/reset-font-size)
#+end_src

** Highlight the current line

=global-hl-line-mode= softly highlights the background color of the line
containing point. It makes it a bit easier to find point, and it's useful when
pairing or presenting code.

#+begin_src emacs-lisp
  (global-hl-line-mode)
#+end_src

** Highlight uncommitted changes

Use the =diff-hl= package to highlight changed-and-uncommitted lines when
programming.

#+begin_src emacs-lisp
  (use-package diff-hl
    :config
    :hook ((text-mode prog-mode vc-dir-mode) . turn-on-diff-hl-mode))
#+end_src

* Project management

I use a few packages in virtually every programming or writing environment to
manage the project, handle auto-completion, search for terms, and deal with
version control. That's all in here.

** =ripgrep=

Install =ripgrep= to provide search within projects. Search even "hidden" dotfiles.

#+begin_src emacs-lisp
  (use-package deadgrep
    :ensure-system-package (rg . ripgrep)
    :config
    (defun deadgrep--include-args (rg-args)
      (push "--hidden" rg-args))
    (advice-add 'deadgrep--arguments
                :filter-return #'deadgrep--include-args))
#+end_src

** =company=

Use =company-mode= everywhere.

#+begin_src emacs-lisp
  (use-package company
    :hook (prog-mode . company-mode)
    :bind (:map company-active-map
                ("<tab>" . company-complete-selection))

    :custom
    (company-backends '((company-capf company-dabbrev-code)))
    (company-idle-delay 0)
    (company-minimum-prefix-length 3)
    (company-tooltip-align-annotations t)
    (company-tooltip-limit 20)

    :config
    (setq lsp-completion-provider :capf))
#+end_src

[[https://github.com/sebastiencs/company-box][company-box]] adds some semantic icons to the =company= completion menu.

#+begin_src emacs-lisp
  (use-package all-the-icons)
  (use-package company-box
    :after company
    :hook (company-mode . company-box-mode)

    :config
    (setq company-box-icons-alist 'company-box-icons-all-the-icons))
#+end_src

** =docker=

I use [[https://www.docker.com/][Docker]] less often than you might expect for a person who mostly does Web
development, but when I do [[https://github.com/Silex/docker.el][=docker.el=]] provides a convenient, =magit=-like
interface for managing containers.

#+begin_src emacs-lisp
  (use-package docker
    :ensure-system-package docker)
#+end_src

** =dumb-jump=

The =dumb-jump= package works well enough in a [[https://github.com/jacktasia/dumb-jump#supported-languages][ton of environments]], and it doesn't
require any additional setup. I've bound its most useful command to =M-.=.

#+begin_src emacs-lisp
  (use-package dumb-jump
    :config
    (add-hook 'xref-backend-functions #'dumb-jump-xref-activate)
    (define-key evil-normal-state-map (kbd "M-.") 'xref-find-definitions))
#+end_src

The =xref-find-definitions= function creates an =XREF= buffer of results if more
than one thing matches. That's inconvenient; I'd rather use Ivy to select among
them.

#+begin_src emacs-lisp
  (use-package ivy-xref
    :init
    (setq xref-show-definitions-function #'ivy-xref-show-defs))
#+end_src

** =flycheck=

I'd like to enable flycheck all kinds of places.

#+begin_src emacs-lisp
  (use-package let-alist)
  (use-package flycheck
    :init (global-flycheck-mode))
#+end_src

** =magit=

I use =magit= to handle version control. It's lovely, but I tweak a few things:

- I bring up the status menu with =C-x g=.
- The default behavior of =magit= is to ask before pushing. I haven't had any
  problems with accidentally pushing, so I'd rather not confirm that every time.
- Per [[http://tbaggery.com/2008/04/19/a-note-about-git-commit-messages.html][tpope's suggestions]], highlight commit text in the summary line that goes
  beyond 50 characters.
- I'd like to start in the insert state when writing a commit message.

#+begin_src emacs-lisp
  (use-package magit
    :ensure-system-package git
    :hook (with-editor-mode . evil-insert-state)
    :bind ("C-x g" . magit-status)

    :config
    (use-package git-commit)
    (use-package magit-section)
    (use-package with-editor)

    (require 'git-rebase)

    (setq magit-push-always-verify nil
          git-commit-summary-max-length 50))
#+end_src

I'm also partial to =git-timemachine=, which lets you quickly page through the
history of a file.

#+begin_src emacs-lisp
  (use-package git-timemachine)
#+end_src

** =projectile=

Projectile's default search bindings are clunky enough that I rarely use them
(and forget them when I need them). This binds searching to the easier-to-type
=C-c v=.

Bind =C-p= to fuzzy-finding files in the current project. We also need to
explicitly set that in a few other modes.

I use =ivy= as my completion system.

When I visit a project with =projectile-switch-project=, the default action is
to search for a file in that project. I'd rather just open up the top-level
directory of the project in =dired= and find (or create) new files from there.

I'd like to /always/ be able to recursively fuzzy-search for files, not just
when I'm in a Projectile-defined project. I use the current directory as a
project root (if I'm not in a "real" project).

#+begin_src emacs-lisp
  (use-package projectile
    :bind
    ("C-c v" . deadgrep)

    :config
    (define-key projectile-mode-map (kbd "C-c p") 'projectile-command-map)

    (define-key evil-normal-state-map (kbd "C-p") 'projectile-find-file)
    (evil-define-key 'motion deadgrep-mode-map (kbd "C-p") 'projectile-find-file)
    (evil-define-key 'motion rspec-mode-map (kbd "C-p") 'projectile-find-file)
    (evil-define-key 'motion rspec-compilation-mode-map (kbd "C-p") 'projectile-find-file)

    (setq projectile-completion-system 'ivy
          projectile-switch-project-action 'projectile-dired
          projectile-require-project-root nil)

    (projectile-global-mode))
#+end_src

** =undo-tree=

I like tree-based undo management. I only rarely need it, but when I do, oh boy.

This also registers =undo-tree= for use in =evil-mode=.

#+begin_src emacs-lisp
  (use-package undo-tree
    :config
    (setq undo-tree-history-directory-alist `(("." . ,(concat user-emacs-directory "undo-tree"))))
    (global-undo-tree-mode)
    (evil-set-undo-system 'undo-tree))
#+end_src

* Programming environments

I like shallow indentation, but tabs are displayed as 8 characters by default.
This reduces that.

#+begin_src emacs-lisp
  (setq-default tab-width 2)
#+end_src

Treating terms in CamelCase symbols as separate words makes editing a little
easier for me, so I like to use =subword-mode= everywhere.

#+begin_src emacs-lisp
  (use-package subword
    :config (global-subword-mode 1))
#+end_src

Compilation output goes to the =*compilation*= buffer. I rarely have that window
selected, so the compilation output disappears past the bottom of the window.
This automatically scrolls the compilation window so I can always see the
output.

#+begin_src emacs-lisp
  (setq compilation-scroll-output t)
#+end_src

I use LSP for some languages. This hooks LSP to run in those modes and ensures
that it displays all available documentation on hover.

#+begin_src emacs-lisp
  (use-package lsp-mode
    :commands (lsp lsp-deferred)
    :hook ((go-mode ruby-mode) . lsp-deferred)

    :custom
    (lsp-eldoc-render-all t))
#+end_src

This integrates LSP into my UI in various useful ways. Specifically, it writes
documentation an d type annotations and suchlike all over my damn screen, which
/I/ enjoy, personally.

#+begin_src emacs-lisp
  (use-package lsp-ui
    :commands lsp-ui-mode
    :defer t
    :hook (lsp-mode . lsp-ui-mode)

    :custom
    (lsp-ui-peek-always-show t)
    (lsp-ui-sideline-show-hover t)
    (lsp-ui-doc-enable nil))
#+end_src

** Coq

I use =company-coq-mode=, which really helps make Proof General a more useful IDE.

#+begin_src emacs-lisp
  (use-package proof-general
    :ensure-system-package (coqc . coq))
  (use-package company-coq)
#+end_src

I bind the right and left arrow keys to evaluating and retracting the next and
previous statements. This is more convenient than the default bindings of =C-c
C-n= and =C-c C-u=.

I also like to disable =abbrev-mode=; it has a ton of abbreviations for Coq, but
they've always been unpleasant surprises for me.

#+begin_src emacs-lisp
  (add-hook 'coq-mode-hook
            (lambda ()
              (company-coq-mode)
              (evil-define-key 'normal coq-mode-map (kbd "<down>") 'proof-assert-next-command-interactive)
              (evil-define-key 'normal coq-mode-map (kbd "<up>") 'proof-undo-last-successful-command)
              (evil-define-key 'normal coq-mode-map (kbd "<return>") 'company-coq-proof-goto-point)
              (abbrev-mode 0)))
#+end_src

The default Proof General layout stacks the code, goal, and response buffers on
top of each other. I like to keep my code on one side and my goal and response
buffers on the other.

#+begin_src emacs-lisp
  (setq proof-three-window-mode-policy 'hybrid)
#+end_src

Don't move point when asserting and undoing proof commands.

#+begin_src emacs-lisp
  (setq proof-follow-mode 'ignore)
#+end_src

The Proof General splash screen's pretty cute, but I don't need to see it every
time.

#+begin_src emacs-lisp
  (setq proof-splash-enable nil)
#+end_src

Proof General usually evaluates each comment individually. In literate programs,
this can result in evaluating a /ton/ of comments. This evaluates a series of
consecutive comments as a single comment.

#+begin_src emacs-lisp
  (setq proof-script-fly-past-comments t)
#+end_src

** CSS & Sass

Indent by 2 spaces.

#+begin_src emacs-lisp
  (use-package css-mode
    :config
    (setq css-indent-offset 2))
#+end_src

Don't compile the current SCSS file every time I save.

#+begin_src emacs-lisp
  (use-package scss-mode
    :config
    (setq scss-compile-at-save nil))
#+end_src

** Go

Install =go-mode=, plus =protobuf-mode=.

#+begin_src emacs-lisp
  (use-package go-mode
    :ensure-system-package (go . golang)
    :bind
    (:map go-mode-map ("C-c C-c" . compile)))

  (use-package protobuf-mode)
#+end_src

Define my =$GOPATH= and tell Emacs where to find the Go binaries.

#+begin_src emacs-lisp
  (setenv "GOPATH" "/home/hrs/code/go")
  (hrs/append-to-path (concat (getenv "GOPATH") "/bin"))
#+end_src

When I save a Go file, reformat the buffer (per =gofmt=) and organize the imports
(per =goimports=).

#+begin_src emacs-lisp
  (defun hrs/install-go-save-hooks ()
    (add-hook 'before-save-hook #'lsp-format-buffer t t)
    (add-hook 'before-save-hook #'lsp-organize-imports t t))

  (add-hook 'go-mode-hook #'hrs/install-go-save-hooks)
#+end_src

Redefine the default =compile= command to build the whole project, run tests, and
run =go vet= without requiring any additional confirmation. That's bound to =C-c
C-c= in the =use-package= configuration above.

#+begin_src emacs-lisp
  (defun hrs/set-go-compilation-configuration ()
    (set (make-local-variable 'compilation-read-command) nil)
    (set (make-local-variable 'compile-command)
         "go build -v ./... && go test -race ./... && go vet ./...")
    (set (make-local-variable 'default-directory) (projectile-project-root)))

  (add-hook 'go-mode-hook #'hrs/set-go-compilation-configuration)
#+end_src

** Haskell

#+begin_src emacs-lisp
  (use-package haskell-mode)
#+end_src

Enable =haskell-doc-mode=, which displays the type signature of a function, and
use smart indentation.

#+begin_src emacs-lisp
  (add-hook 'haskell-mode-hook
            (lambda ()
              (haskell-doc-mode)
              (turn-on-haskell-indent)))
#+end_src

#+begin_src emacs-lisp
  (hrs/append-to-path "~/.cabal/bin")
#+end_src

** JavaScript

Indent everything by 2 spaces.

#+begin_src emacs-lisp
  (setq js-indent-level 2)
#+end_src

** Lisps

=rainbow-delimiters= is convenient for coloring matching parentheses.

#+begin_src emacs-lisp
  (use-package rainbow-delimiters
    :hook ((emacs-lisp-mode lisp-mode racket-mode) . rainbow-delimiters-mode))
#+end_src

*** Common Lisp

Set up [[https://slime.common-lisp.dev/][SLIME]] to interactively hack on Common Lisp.

#+begin_src emacs-lisp
  (use-package slime
    :ensure-system-package sbcl
    :config
    (load (expand-file-name "~/.quicklisp/slime-helper.el"))
    (add-to-list 'slime-contribs 'slime-autodoc)
    (setq inferior-lisp-program "sbcl"))
#+end_src

*** Emacs Lisp

If I'm writing in Emacs Lisp I'd like to use =eldoc-mode= to display
documentation.

#+begin_src emacs-lisp
  (use-package eldoc
    :hook (emacs-lisp-mode . eldoc-mode))
#+end_src

*** Racket

#+begin_src emacs-lisp
  (use-package geiser
    :ensure-system-package racket
    :config
    (setq geiser-active-implementations '(racket)))

  (use-package racket-mode
    :hook (racket-mode . racket-xp-mode)
    :mode "\\.rkt\\'")
#+end_src

Quit documentation buffers.

 #+begin_src emacs-lisp
  (evil-define-key 'normal racket-describe-mode (kbd "q") 'quit-window)
#+end_src

** OCaml

Use =tuareg-mode= for editing OCaml.

#+begin_src emacs-lisp
  (use-package tuareg
    :ensure-system-package opam
    :config
    (electric-indent-mode 0))
#+end_src

Configure Merlin. This also requires installing the Merlin package through OPAM
with =opam install merlin=.

#+begin_src emacs-lisp
  (use-package merlin
    :hook (tuareg-mode . merlin-mode))
#+end_src

Add =~/.opam/default/bin= to load path. That's where =dune=, our build tool, is
installed.

#+begin_src emacs-lisp
  (hrs/append-to-path "~/.opam/default/bin")
#+end_src

** Python

#+begin_src emacs-lisp
  (use-package python-mode)
#+end_src

Add =~/.local/bin= to load path. That's where =virtualenv= is installed, and
we'll need that for =jedi=.

#+begin_src emacs-lisp
  (hrs/append-to-path "~/.local/bin")
#+end_src

Enable =elpy=. This provides automatic indentation, auto-completion, syntax
checking, etc.

#+begin_src emacs-lisp
  (use-package elpy)
  (elpy-enable)
#+end_src

Format code according to PEP8 on save:

#+begin_src emacs-lisp
  (use-package py-autopep8)
  (require 'py-autopep8)
  (add-hook 'elpy-mode-hook 'py-autopep8-enable-on-save)
#+end_src

Use the =python3= interpreter for eldoc:

#+begin_src emacs-lisp
  (setq elpy-rpc-python-command "python3")
#+end_src

** Ruby

This defines a default Ruby version to use within Emacs (for things like =xmp= or
=rspec=).

#+begin_src emacs-lisp
  (setq hrs/ruby-version "3.1.0")
#+end_src

Ruby executables are installed in =~/.gem/ruby/<version>/bin=. This ensures that
that's included in the path. In particular, we want that directory to be
included because it contains the =xmpfilter= executable.

#+begin_src emacs-lisp
  (hrs/append-to-path (format "~/.gem/ruby/%s/bin" hrs/ruby-version))
#+end_src

I associate =ruby-mode= with Gemfiles, gemspecs, Rakefiles, and Vagrantfiles.

There are a bunch of things I'd like to do when I open a Ruby buffer:

- =C-c C-c= should run =xmp=, to do that nifty "eval into comments" trick.
- Hitting "enter" should indent to the current level.
- When assigning the result of a conditional, I like to align the expression to
  match the beginning of the statement instead of indenting it all the way to
  the =if=.

#+begin_src emacs-lisp
  (use-package ruby-mode
    :ensure-system-package (xmpfilter . "gem install rcodetools")

    :mode ("\\.rake$"
           "\\.gemspec$"
           "\\Guardfile$"
           "\\Rakefile$"
           "\\Vagrantfile$"
           "\\Vagrantfile.local$")

    :bind (("C-c C-c" . xmp)
           ("\r" . newline-and-indent))

    :config
    (setq ruby-align-to-stmt-keywords '(def if)))
#+end_src

I use =chruby= to switch between versions of Ruby.

#+begin_src emacs-lisp
  (use-package chruby
    :hook (ruby . chruby-use-corresponding)
    :config
    (chruby hrs/ruby-version))
#+end_src

Running tests from within Emacs is awfully convenient. I enable =rspec-mode=
basically everywhere, since working with a Rails project involves a ton of
modes.

I'd like my RSpec tests to be run in a random order, and I'd like the output to
be colored.

#+begin_src emacs-lisp
  (use-package rspec-mode
    :ensure-system-package (rspec . "gem install rspec")

    :hook (css-mode
           deadgrep-mode
           eldoc-mode
           js-mode
           magit-status-mode
           ruby-mode
           scss-mode
           web-mode
           yard-mode)

    :config
    (add-hook 'compilation-filter-hook 'inf-ruby-auto-enter)
    (setq compilation-scroll-output nil
          rspec-command-options "--color --order random"
          rspec-use-chruby t))
#+end_src

=rcodetools= provides =xmp=, which lets me evaluate a Ruby buffer and display the
results in "magic" (=# ==>=) comments.

I disable warnings when running code through =xmp= because I disagree with a few
of them (complaining about private =attr_reader=, especially) and they gunk up my
buffer.

#+begin_src emacs-lisp
  (setq xmpfilter-command-name
        "ruby -S xmpfilter --no-warnings --dev --fork --detect-rbtest")

  (add-to-list 'load-path (concat user-emacs-directory "resources"))
  (require 'rcodetools)
#+end_src

Ruby method comments are often formatted with Yard.

#+begin_src emacs-lisp
  (use-package yard-mode
    :hook ruby-mode)
#+end_src

Insert =end= keywords automatically when I start to define a method, class,
module, or block.

#+begin_src emacs-lisp
  (use-package ruby-end)
#+end_src

Install and enable =projectile-rails= mode in all Rail-related buffers.

#+begin_src emacs-lisp
  (use-package projectile-rails
    :config
    (projectile-rails-global-mode))
#+end_src

** Rust

Use =rustic= to edit Rust code.

#+begin_src emacs-lisp
  (use-package rustic
    :bind (:map rustic-mode-map
                ("M-j" . lsp-ui-imenu)
                ("M-?" . lsp-find-references)
                ("C-c C-c l" . flycheck-list-errors)
                ("C-c C-c a" . lsp-execute-code-action)
                ("C-c C-c r" . lsp-rename)
                ("C-c C-c q" . lsp-workspace-restart)
                ("C-c C-c Q" . lsp-workspace-shutdown)
                ("C-c C-c s" . lsp-rust-analyzer-status))

    :config
    (setq lsp-rust-analyzer-cargo-watch-command "clippy")
    (setq lsp-rust-analyzer-server-display-inlay-hints t)

    (hrs/append-to-path "~/.cargo/bin")
    (setq rustic-format-on-save t)
    (add-hook 'rustic-mode-hook 'hrs/rustic-mode-hook))

  (defun hrs/rustic-mode-hook ()
    "Don't prompt for confirmation before running `rustfmt'."
    (setq-local buffer-save-without-query t))
#+end_src

** =sh=

Indent with 2 spaces.

#+begin_src emacs-lisp
  (add-hook 'sh-mode-hook
            (lambda ()
              (setq sh-basic-offset 2
                    sh-indentation 2)))
#+end_src

** Scala

Ensure that =scala-mode= and =sbt-mode= are installed.

#+begin_src emacs-lisp
  (use-package scala-mode
    :interpreter
    ("scala" . scala-mode))

  (use-package sbt-mode
    :commands sbt-start sbt-command
    :config
    (substitute-key-definition
     'minibuffer-complete-word
     'self-insert-command
     minibuffer-local-completion-map))

  (use-package hydra)
#+end_src

Don't show the startup message with launching ENSIME:

#+begin_src emacs-lisp
  (setq ensime-startup-notification nil)
#+end_src

Bind a few keys to common operations:

#+begin_src emacs-lisp
  (evil-define-key 'normal ensime-mode-map (kbd "C-t") 'ensime-type-at-point)
  (evil-define-key 'normal ensime-mode-map (kbd "M-.") 'ensime-edit-definition)
#+end_src

** SQL

Support syntax-based indentation when editing SQL files.

#+begin_src emacs-lisp
  (use-package sql-indent
    :hook (sql-mode . sqlind-minor-mode))
#+end_src

** Terraform

Install =terraform-mode=.

#+begin_src emacs-lisp
  (use-package terraform-mode)
  (use-package company-terraform)
#+end_src

** =web-mode=

Use =web-mode= with embedded Ruby files, regular HTML, and PHP.

#+begin_src emacs-lisp
  (use-package web-mode
    :mode ("\\.erb$"
           "\\.html$"
           "\\.php$"
           "\\.rhtml$")

    :config
    (setq web-mode-markup-indent-offset 2
          web-mode-css-indent-offset 2
          web-mode-code-indent-offset 2
          web-mode-indent-style 2))
#+end_src

I'd like to see colors with =rainbow-mode=, so we'll need to install that, too:

#+begin_src emacs-lisp
  (use-package rainbow-mode
    :hook web-mode)
#+end_src

** YAML

Ensure that we always use =fixed-pitch= fonts for YAML.

#+begin_src emacs-lisp
  (use-package yaml-mode
    :config
    (add-hook 'yaml-mode-hook (lambda () (variable-pitch-mode 0))))
#+end_src

* Terminal

I'm trying =eshell=. Seems promising so far.

#+begin_src emacs-lisp
  (add-to-list 'eshell-modules-list 'eshell-rebind)

  (add-hook 'eshell-mode-hook
            (lambda ()
              (evil-define-key 'insert eshell-mode-map (kbd "C-r") 'counsel-esh-history)
              (evil-define-key 'insert eshell-mode-map (kbd "C-d") 'hrs/kill-process)))
#+end_src

Don't show the =eshell= welcome message.

#+begin_src emacs-lisp
 (setq eshell-banner-message "")
#+end_src

I open up a new shell instance with =C-c t=.

#+begin_src emacs-lisp
  (defun hrs/new-eshell ()
    "Open a fresh eshell buffer."
    (interactive)
    (eshell 'N))

  (global-set-key (kbd "C-c t") 'hrs/new-eshell)
#+end_src

Suppose I've got an Emacs frame open and displaying an =eshell= process. If I hit
=C-d=, I'd like the following behavior:

- If this is the only visible Emacs frame, just kill the process and kill the
  associated buffer.
- If there's another visible Emacs frame, kill the process and buffer, and then
  also delete the frame.

The idea here is to /mostly/ replicate the behavior of terminal emulators like
=xterm=, in that I'd like to be able to pop open an =eshell= on an i3 desktop, run a
command, and quickly close it with =C-d=. But if I'm running a terminal in the
only remaining Emacs frame, I usually want to leave that open so I can do other
Emacsitting after I'm done with that shell.

#+begin_src emacs-lisp
  (defun daemon-frame-p (frame)
    "Return t if FRAME is the virtual frame associated with the daemon.

When starting Emacs with `--daemon', a virtual frame is created
that `contains' the daemon. This frame isn't actually visible to
the user."
    (and (framep frame)
         (string-equal "initial_terminal"
                       (terminal-name frame))))

  (defun visible-frames ()
    "Return a list of all frames that are currently visible to the user.

This excludes both invisible frames and the daemon's virtual frame."
    (-filter (lambda (frame)
               (and (frame-visible-p frame)
                    (not (daemon-frame-p frame))))
             (frame-list)))

  (defun last-visible-frame-p ()
    "Return t if only one frame is currently visible to the user."
    (= 1 (length (visible-frames))))

  (defun hrs/kill-process ()
    "Kill the current `eshell' buffer.

If this isn't the only visible frame, kill the frame, too."
    (interactive)
    (when (eobp)
      (cond
       ((/= (point) eshell-last-output-end)
        (beep))
       ((eshell-interactive-process)
        (process-send-eof))
       (t
        (eshell-life-is-too-much)
        (when (not (last-visible-frame-p))
          (delete-frame))))))

    (add-hook 'term-mode-hook
              (lambda ()
                (evil-define-key 'insert term-raw-map (kbd "C-d") 'hrs/kill-process)))
#+end_src

* Password management

I manage my passwords with [[https://www.passwordstore.org/][=pass=]], a nifty command-line utility that's
accessible through Emacs.

I'll also occasionally use =pwgen= to generate and insert a secure password.

#+begin_src emacs-lisp
  (use-package password-store
    :ensure-system-package pass)

  (use-package password-store-otp)

  (defun hrs/insert-password ()
    (interactive)
    (shell-command "pwgen 30 -1" t))
#+end_src

* Publishing and task management with Org-mode

Including =org-tempo= restores the =<s=-style easy templates that were deprecated in
Org 9.2.

I'd like to open =file:= links in Org with the applications defined in my [[file:~/.dotfiles/email/.mailcap][mailcap]].
This clears the existing MIME mapping, parses my personal mailcap, and tells Org
to open those links with the mailcap-defined applications.

#+begin_src emacs-lisp
  (use-package org
    :config
    (require 'org-tempo)

    (add-hook 'org-mode-hook
              (lambda ()
                (setq mailcap-mime-data '())
                (mailcap-parse-mailcap "~/.mailcap")
                (setq org-file-apps
                      '((auto-mode . emacs)
                        ("mobi" . "fbreader %s")
                        ("\\.x?html?\\'" . mailcap)
                        ("pdf" . mailcap)
                        (system . mailcap)
                        (t . mailcap))))))
#+end_src

I'd like the initial scratch buffer to be in Org:

#+begin_src emacs-lisp
  (setq initial-major-mode 'org-mode)
#+end_src

** Display preferences

I like to see an outline of pretty bullets instead of a list of asterisks.

#+begin_src emacs-lisp
  (use-package org-superstar
    :config
    (setq org-superstar-special-todo-items t)
    (setq org-hide-leading-stars t)
    (add-hook 'org-mode-hook (lambda ()
                               (org-superstar-mode 1))))
#+end_src

This hides the slashes and stars that denote /emphasis/ and *bold* text unless point
is on said text.

#+begin_src emacs-lisp
  (setq org-hide-emphasis-markers t)

  (use-package org-appear
    :hook (org-mode . org-appear-mode))
#+end_src

When a collapsed heading contains content, show an [[https://typographyforlawyers.com/ellipses.html][actual ellipsis character]]
rather than a triple-dot bastardization.

#+begin_src emacs-lisp
  (setq org-ellipsis "…")
#+end_src

Put tags directly after the associated header rather than trying to align them.

#+begin_src emacs-lisp
  (setq org-auto-align-tags nil
        org-tags-column 0)
#+end_src

Visibly render mathematical symbols.

#+begin_src emacs-lisp
  (setq org-pretty-entities t)
#+end_src

Show linked images directly in my Org document. Don't fully expand enormous
images; instead, use =imagemagick= to display them at a manageable size.

#+begin_src emacs-lisp
  (setq org-startup-with-inline-images t
        org-image-actual-width '(600))
#+end_src

Use syntax highlighting in source blocks while editing.

#+begin_src emacs-lisp
  (setq org-src-fontify-natively t)
#+end_src

Make TAB act as if it were issued in a buffer of the language's major mode.

#+begin_src emacs-lisp
  (setq org-src-tab-acts-natively t)
#+end_src

When editing a code snippet, use the current window rather than popping open a
new one (which shows the same information).

#+begin_src emacs-lisp
  (setq org-src-window-setup 'current-window)
#+end_src

Quickly insert a block of elisp:

#+begin_src emacs-lisp
  (add-to-list 'org-structure-template-alist
               '("el" . "src emacs-lisp"))
#+end_src

Don't indent newly expanded blocks, even if they're under a heading.

#+begin_src emacs-lisp
  (setq org-adapt-indentation nil)
#+end_src

When hitting =C-<return>= to create a new heading, don't insert the heading
between the current heading and its content, but instead append it /after/ the
content.

#+begin_src emacs-lisp
  (setq org-insert-heading-respect-content t)
#+end_src

** Task management and agenda views

Store my org files in =~/documents/org=, maintain an inbox in Dropbox, define
the location of an index file (my main todo list), and archive finished tasks in
=~/documents/org/archive.org=.

#+begin_src emacs-lisp
  (setq org-directory "~/documents/org")

  (defun org-file-path (filename)
    "Return the absolute address of an org file, given its relative name."
    (concat (file-name-as-directory org-directory) filename))

  (setq org-inbox-file "~/sync/Dropbox/inbox.org")
  (setq org-index-file (org-file-path "index.org"))
  (setq org-archive-location
        (concat
         (org-file-path (format "archive/archive-%s.org" (format-time-string "%Y")))
         "::* From %s"))

  (setq org-refile-targets `((,org-index-file :level . 1)
                             (,(org-file-path "deliveries.org") :level . 1)
                             (,(org-file-path "environment.org") :level . 1)
                             (,(org-file-path "goals.org") :level . 1)
                             (,(org-file-path "links.org") :level . 1)
                             (,(org-file-path "media.org") :level . 1)
                             (,(org-file-path "someday-maybe.org") :level . 1)
                             (,(org-file-path "work.org") :level . 1)))
#+end_src

I store most of my personal tasks in my index and maintain a separate file for
work-related tasks, so I'd like to derive my agenda from those files. I've also
got some annual OKRs in =goals.org=.

I also keep a schedule in =events.org=. Plus some recurring events in,
reasonably, a =recurring-events.org= file. Those are (mostly) structured as
=org-habit= items so they can recur according to a schedule.

#+begin_src emacs-lisp
  (setq org-agenda-files (list org-index-file
                               (org-file-path "calendars")
                               (org-file-path "deliveries.org")
                               (org-file-path "goals.org")
                               (org-file-path "habits.org")
                               (org-file-path "news.org")
                               (org-file-path "recurring-events.org")
                               (org-file-path "recurring-tasks.org")
                               (org-file-path "work.org")
                               (org-file-path "writing.org")))
#+end_src

Hitting =C-c C-x C-s= will mark a task as done, move it to an appropriate place in
the archive, and save all the Org buffers.

#+begin_src emacs-lisp
  (defun hrs/mark-done-and-archive ()
    "Mark the state of an org-mode item as DONE, archive it, and
save the Org buffers."
    (interactive)
    (org-todo 'done)
    (org-archive-subtree)
    (org-save-all-org-buffers))

  (define-key org-mode-map (kbd "C-c C-x C-s") 'hrs/mark-done-and-archive)
#+end_src

Record the time that a todo was archived.

#+begin_src emacs-lisp
  (setq org-log-done 'time)
#+end_src

Ensure that a task can't be marked as done if it contains unfinished subtasks.
This is handy for organizing "blocking" tasks hierarchically.

#+begin_src emacs-lisp
  (setq org-enforce-todo-dependencies t)
#+end_src

Schedule a task for today.

#+begin_src emacs-lisp
  (defun hrs/org-add-tag (new-tag)
    (org-set-tags (cons new-tag
                        (seq-remove (lambda (tag)
                                      (get-text-property 0 'inherited tag))
                                    (org-get-tags)))))

  (defun hrs/refile-to (file headline)
    "Move current headline to specified location"
    (let ((pos (save-excursion
                 (find-file file)
                 (org-find-exact-headline-in-buffer headline))))
      (org-refile nil nil (list headline file nil pos))))

  (defun hrs/refile-to-tasks ()
    "Move current headline to bookmarks"
    (interactive)
    (org-mark-ring-push)
    (hrs/refile-to org-index-file "Tasks")
    (org-mark-ring-goto))

  (defun hrs/schedule-today ()
    "Tag this item with `daily'."
    (interactive)
    (hrs/org-add-tag "daily")
    (hrs/refile-to-tasks)
    (save-buffer))
#+end_src

Begin weeks /today/, not on the last Monday.

#+begin_src emacs-lisp
  (setq org-agenda-start-on-weekday nil)
#+end_src

Don't show deadline warnings under today's entry. If something's due in two
days, I'll see it in my agenda as a deadline on that day; I don't /also/ need it
listed under today's tasks, prefixed with =In 2 d:=.

#+begin_src emacs-lisp
  (setq org-deadline-warning-days 0)
#+end_src

Separate org blocks with nearly complete lines, not rows of ===.

#+begin_src emacs-lisp
  (setq org-agenda-block-separator ?─
        org-agenda-time-grid
        '((daily today require-timed)
          (800 1000 1200 1400 1600 1800 2000)
          " ┄┄┄┄┄ " "┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄")
        org-agenda-current-time-string
        "⭠ now ─────────────────────────────────────────────────")
#+end_src

Hide the category prefix from tasks. I categorize my tasks with tags, including
using =filetags=, so prefixing tasks with the file they're stored in is noisy and
redundant.

#+begin_src emacs-lisp
  (setq org-agenda-prefix-format '((agenda . " %i %?-12t% s")
                                   (todo . " %i ")
                                   (tags . " %i ")
                                   (search . " %i ")))
#+end_src

By default Org will dim any tasks that contain blocking subtasks. That's good,
but I've got enough of those that I'd rather not see them at all.

By making blocked tasks invisible I ensure that everything in my agenda is
currently actionable. Or, in GTD lingo, I'm only seeing "next steps."

#+begin_src emacs-lisp
  (setq org-agenda-dim-blocked-tasks 'invisible)
#+end_src

Hide blocks in the agenda that don't contain any tasks. From [[https://lists.gnu.org/archive/html/emacs-orgmode/2015-06/msg00266.html][this email thread]].

#+begin_src emacs-lisp
  (defun org-agenda-delete-empty-blocks ()
    "Remove empty agenda blocks.
  A block is identified as empty if there are fewer than 2
  non-empty lines in the block (excluding the line with
  `org-agenda-block-separator' characters)."
    (when org-agenda-compact-blocks
      (user-error "Cannot delete empty compact blocks"))
    (setq buffer-read-only nil)
    (save-excursion
      (goto-char (point-min))
      (let* ((blank-line-re "^\\s-*$")
             (content-line-count (if (looking-at-p blank-line-re) 0 1))
             (start-pos (point))
             (block-re (format "%c\\{10,\\}" org-agenda-block-separator)))
        (while (and (not (eobp)) (forward-line))
          (cond
           ((looking-at-p block-re)
            (when (< content-line-count 2)
              (delete-region start-pos (1+ (point-at-bol))))
            (setq start-pos (point))
            (forward-line)
            (setq content-line-count (if (looking-at-p blank-line-re) 0 1)))
           ((not (looking-at-p blank-line-re))
            (setq content-line-count (1+ content-line-count)))))
        (when (< content-line-count 2)
          (delete-region start-pos (point-max)))
        (goto-char (point-min))
        ;; The above strategy can leave a separator line at the beginning
        ;; of the buffer.
        (when (looking-at-p block-re)
          (delete-region (point) (1+ (point-at-eol))))))
    (setq buffer-read-only t))

  (add-hook 'org-agenda-finalize-hook #'org-agenda-delete-empty-blocks)
#+end_src

The "Personal agenda" view is simpler than it seems. I'm mostly sorting tasks by
the =inbox=, =habit=, =daily=, and =yearly= tags. Here are the sections:

- Inbox :: Newly captured notes or ideas that haven't yet been turned into
  "real" tasks or projects.
- Daily :: Things I want to do today.
- Habit :: Automatically generated tasks appended to a file with a custom
  script. This includes stuff like, y'know, exercising, feeding the sourdough
  starter, or resetting my watch for daylight savings time. I could probably
  replace this script with [[https://orgmode.org/manual/Tracking-your-habits.html][org-habit]], but I don't for mostly historical reasons.
- Calendar :: I have a =cron= job that pulls down my calendars into an Org file,
  so my day's meetings, pending deliveries, and so on are displayed in my
  agenda. This also shows tasks with deadlines and so on that I might not have
  tagged.
- Annual Goals :: The big projects I want to get done this year.
- Unscheduled Tasks :: Miscellaneous tasks that don't fit into any of the above
  categories.

#+begin_src emacs-lisp
  (setq org-agenda-custom-commands '())

  (add-to-list 'org-agenda-custom-commands
               '("p" "Personal agenda"
                 ((tags-todo "plan"
                             ((org-agenda-overriding-header "Inbox")
                              (org-agenda-hide-tags-regexp "plan\\|daily\\|yearly")))

                  (tags-todo "daily"
                             ((org-agenda-overriding-header "Today")
                              (org-agenda-hide-tags-regexp "habit\\|daily\\|yearly")))

                  (tags-todo "habit-daily"
                             ((org-agenda-overriding-header "Habits")
                              (org-agenda-hide-tags-regexp "habit")))

                  (agenda ""
                          ((org-agenda-overriding-header "Calendar")
                           (org-agenda-tag-filter-preset '("-daily"
                                                           "-habit"
                                                           "-yearly"))
                           (org-agenda-hide-tags-regexp "daily\\|yearly")))

                  (tags-todo "yearly-daily"
                             ((org-agenda-overriding-header "Annual Goals")
                              (org-agenda-hide-tags-regexp "yearly"))))

                 ((org-agenda-skip-deadline-if-done t)
                  (org-agenda-skip-scheduled-if-done t)
                  (org-agenda-skip-timestamp-if-done t)
                  (org-agenda-tag-filter-preset '("-duplicate" "-news" "-writing")))))
#+end_src

I consult my agenda pretty often, so I bind =C-c d= to open it a bit faster. This
also copies any files I've sent through Drafts into my index file before
displaying the index so that they'll appear in the agenda view, too.

#+begin_src emacs-lisp
  (defun hrs/dashboard ()
    (interactive)
    (call-process-shell-command "daily-checklist")
    (delete-other-windows)
    (find-file org-index-file)
    (org-agenda nil "p"))

  (global-set-key (kbd "C-c d") 'hrs/dashboard)
#+end_src

Shorten the default (lengthy) =org-agenda= modeline.

#+begin_src emacs-lisp
  (defadvice org-agenda-set-mode-name (after truncate-org-agenda-mode-name activate)
    (setq mode-name '("Org-agenda")))
#+end_src

I have a number of standing weekly video calls with friends and family, and I
like keeping track of what happened in the last week to share on those calls.
Because my memories only exist in text files, I have a custom view to list news
items from the last week.

#+begin_src emacs-lisp
  (add-to-list 'org-agenda-custom-commands
               '("n" "News from this week"
                 ((agenda ""))
                 ((org-agenda-overriding-header "News from this week")
                  (org-agenda-start-day "-7d")
                  (org-agenda-span 14)
                  (org-agenda-files '("~/documents/org/news.org"
                                      "~/documents/org/recurring-events.org"
                                      "~/documents/notes/books-read.org"
                                      "~/documents/notes/papers-read.org")))))
#+end_src

I do a ton of journaling! I maintain a list of topics I'd like to think through
and pop it open when I'm ready to write.

#+begin_src emacs-lisp
  (add-to-list 'org-agenda-custom-commands
               '("w" "Writing prompts"
                 ((tags "+writing"))
                 ((org-agenda-overriding-header "Writing prompts")
                  (org-agenda-sorting-strategy '((agenda ts-down))))))
#+end_src

*** Capturing tasks

Define a few common tasks as capture templates.

#+begin_src emacs-lisp
  (defvar org-capture-templates '())

  (add-to-list 'org-capture-templates
               '("b" "Blog idea"
                 entry
                 (file "~/documents/notes/blog-ideas.org")
                 "* %?\n"))

  (add-to-list 'org-capture-templates
               '("c" "Contact"
                 entry
                 (file "~/documents/contacts.org")
                 "* %(org-contacts-template-name)
:PROPERTIES:
:ADDRESS: %^{123 Fake St., City, ST 12345}
:PHONE: %^{555-555-5555}
:EMAIL: %(org-contacts-template-email)
:NOTE: %^{note}
:END:"))

  (add-to-list 'org-capture-templates
               '("d" "Delivery"
                 entry
                 (file+headline "~/documents/org/deliveries.org" "Deliveries")
                 "** %?\n   SCHEDULED: %t\n"))

  (add-to-list 'org-capture-templates
               '("e" "Email"
                 entry
                 (file+headline org-index-file "Inbox")
                 "* TODO %?\n%a\n"))

  (add-to-list 'org-capture-templates
               '("f" "Finished book"
                 entry
                 (file+headline "~/documents/notes/books-read.org" "Books")
                 "* %^{Title} -- %^{Author}\n%t\n"))

  (add-to-list 'org-capture-templates
               '("k" "Kookaburra ingest"
                 entry
                 (file+headline "~/documents/org/kookaburra-ingest.org" "Queue")
                 "* TODO %?\n"))

  (add-to-list 'org-capture-templates
               '("m" "Media queue"
                 item
                 (file+headline "~/documents/org/media.org" "Inbox")
                 "- [ ] %?\n"))

  (add-to-list 'org-capture-templates
               '("n" "News item"
                 entry
                 (file "~/documents/org/news.org")
                 "* %?\n%t\n"))

  (add-to-list 'org-capture-templates
               '("p" "Finished paper"
                 entry
                 (file+headline "~/documents/notes/papers-read.org" "Papers")
                 "* %^{Title} -- %^{Author}\n%t\n"))

  (add-to-list 'org-capture-templates
               '("r" "Writing prompt"
                 entry
                 (file "~/documents/org/writing.org")
                 "* %?\n   %t\n"))

  (add-to-list 'org-capture-templates
               '("s" "Subscribe to an RSS feed"
                 plain
                 (file "~/documents/rss-feeds.org")
                 "*** [[%^{Feed URL}][%^{Feed name}]]"))

  (add-to-list 'org-capture-templates
               '("t" "Task"
                 entry
                 (file+headline org-index-file "Inbox")
                 "* TODO %?\n"))

  (add-to-list 'org-capture-templates
               '("w" "Work task"
                 entry
                 (file+headline "~/documents/org/work.org" "Tasks")
                 "* TODO %?\n"))
#+end_src

When I'm starting an Org capture template I'd like to begin in insert mode. I'm
opening it up in order to start typing something, so this skips a step.

#+begin_src emacs-lisp
  (add-hook 'org-capture-mode-hook 'evil-insert-state)
#+end_src

Refiling according to the document's hierarchy.

#+begin_src emacs-lisp
  (setq org-refile-use-outline-path t)
  (setq org-outline-path-complete-in-steps nil)
#+end_src

*** Keybindings

Bind a few handy keys.

#+begin_src emacs-lisp
  (define-key global-map "\C-cl" 'org-store-link)
  (define-key global-map "\C-ca" 'org-agenda)
  (define-key global-map "\C-cc" 'org-capture)
#+end_src

Hit =C-c i= to quickly open up my todo list.

#+begin_src emacs-lisp
  (defun hrs/open-index-file ()
    "Open the master org TODO list."
    (interactive)
    (find-file org-index-file)
    (flycheck-mode -1)
    (end-of-buffer))

  (global-set-key (kbd "C-c i") 'hrs/open-index-file)
#+end_src

Hit =M-n= to quickly open up a capture template for a new todo.

#+begin_src emacs-lisp
  (defun org-capture-todo ()
    (interactive)
    (org-capture :keys "t"))

  (global-set-key (kbd "M-n") 'org-capture-todo)
  (add-hook 'gfm-mode-hook
            (lambda () (local-set-key (kbd "M-n") 'org-capture-todo)))
  (add-hook 'haskell-mode-hook
            (lambda () (local-set-key (kbd "M-n") 'org-capture-todo)))
#+end_src

Hit =C-c w= to quickly open up my work todo list.

#+begin_src emacs-lisp
  (defun hrs/open-work-file ()
    "Open the work TODO list."
    (interactive)
    (find-file (org-file-path "work.org"))
    (flycheck-mode -1)
    (end-of-buffer))

  (global-set-key (kbd "C-c w") 'hrs/open-work-file)
#+end_src

Rebind =C-c C-l= to [[https://xenodium.com/emacs-dwim-do-what-i-mean/][DWIM]]:

#+begin_src emacs-lisp
  (defun hrs/org-insert-link-dwim ()
    "Like `org-insert-link' but with personal dwim preferences."
    (interactive)
    (let* ((point-in-link (org-in-regexp org-link-any-re 1))
           (clipboard-url (when (string-match-p "^http" (current-kill 0))
                            (current-kill 0)))
           (region-content (when (region-active-p)
                             (buffer-substring-no-properties (region-beginning)
                                                             (region-end)))))
      (cond ((and region-content clipboard-url (not point-in-link))
             (delete-region (region-beginning) (region-end))
             (insert (org-make-link-string clipboard-url region-content))
             (message clipboard-url))
            ((and clipboard-url (not point-in-link))
             (insert (org-make-link-string
                      clipboard-url
                      (read-string "title: "
                                   (with-current-buffer (url-retrieve-synchronously clipboard-url)
                                     (dom-text (car
                                                (dom-by-tag (libxml-parse-html-region
                                                             (point-min)
                                                             (point-max))
                                                            'title))))))))
            (t
             (call-interactively 'org-insert-link)))))

  (define-key org-mode-map (kbd "C-c C-l") 'hrs/org-insert-link-dwim)
#+end_src

** Exporting

Allow export to markdown and beamer (for presentations).

#+begin_src emacs-lisp
  (require 'ox-md)
  (require 'ox-beamer)
#+end_src

Allow =babel= to evaluate code blocks in a handful of languages.

#+begin_src emacs-lisp
  (use-package gnuplot
    :ensure-system-package gnuplot)

  (org-babel-do-load-languages
   'org-babel-load-languages
   '((ditaa . t)
     (dot . t)
     (emacs-lisp . t)
     (gnuplot . t)
     (ruby . t)
     (shell . t)))
     #+end_src

Don't ask before evaluating code blocks.

#+begin_src emacs-lisp
  (setq org-confirm-babel-evaluate nil)
#+end_src

Use =htmlize= to ensure that exported code blocks use syntax highlighting.

#+begin_src emacs-lisp
  (use-package htmlize)
#+end_src

Associate the "dot" language with the =graphviz-dot= major mode.

#+begin_src emacs-lisp
  (use-package graphviz-dot-mode
    :ensure-system-package (dot . graphviz))
  (add-to-list 'org-src-lang-modes '("dot" . graphviz-dot))
#+end_src

Translate regular ol' straight quotes to typographically correct curly quotes
when exporting.

#+begin_src emacs-lisp
  (setq org-export-with-smart-quotes t)
#+end_src

**** Exporting to HTML

Don't include a footer with my contact and publishing information at the bottom
of every exported HTML document.

#+begin_src emacs-lisp
  (setq org-html-postamble nil)
#+end_src

**** Exporting to PDF

I want to produce PDFs with syntax highlighting in the code. The best way to do
that seems to be with the =minted= package, but that package shells out to
=pygments= to do the actual work. =xelatex= usually disallows shell commands; this
enables that.

#+begin_src emacs-lisp
  (setq org-latex-pdf-process
        '("xelatex -shell-escape -interaction nonstopmode -output-directory %o %f"
          "xelatex -shell-escape -interaction nonstopmode -output-directory %o %f"
          "xelatex -shell-escape -interaction nonstopmode -output-directory %o %f"))
#+end_src

Include the =minted= package in all of my LaTeX exports.

#+begin_src emacs-lisp
  (add-to-list 'org-latex-packages-alist '("" "minted"))
  (setq org-latex-listings 'minted)
#+end_src

Remove the intermediate TeX file when exporting to PDF.

#+begin_src emacs-lisp
  (add-to-list 'org-latex-logfiles-extensions "tex")
#+end_src

I often want to export a book without "Part I":

#+begin_src emacs-lisp
  (add-to-list 'org-latex-classes
             '("book-noparts"
                "\\documentclass{book}"
                ("\\chapter{%s}" . "\\chapter*{%s}")
                ("\\section{%s}" . "\\section*{%s}")
                ("\\subsection{%s}" . "\\subsection*{%s}")
                ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
                ("\\paragraph{%s}" . "\\paragraph*{%s}")
                ("\\subparagraph{%s}" . "\\subparagraph*{%s}")))
#+end_src

** TeX configuration

I rarely write LaTeX directly any more, but I often export through it with
org-mode, so I'm keeping them together.

Automatically parse the file after loading it.

#+begin_src emacs-lisp
  (setq TeX-parse-self t)
#+end_src

Always use =pdflatex= when compiling LaTeX documents. I don't really have any
use for DVIs.

#+begin_src emacs-lisp
  (setq TeX-PDF-mode t)
#+end_src

Enable a minor mode for dealing with math (it adds a few useful keybindings),
and always treat the current file as the "main" file. That's intentional, since
I'm usually actually in an org document.

#+begin_src emacs-lisp
  (add-hook 'LaTeX-mode-hook
            (lambda ()
              (LaTeX-math-mode)
              (setq TeX-master t)))
#+end_src

Quickly run =make= in a LaTeX project by hitting =<f5>=.

#+begin_src emacs-lisp
  (add-hook 'LaTeX-mode-hook
            (lambda ()
              (define-key LaTeX-mode-map (kbd "<f5>")
                (lambda ()
                  (interactive)
                  (compile "make")))))
#+end_src

* Blogging

I maintain a blog written in Jekyll. There are plenty of command-line tools to
automate creating a new post, but staying in my editor minimizes friction and
encourages me to write.

This defines a =hrs/new-blog-post= function, which prompts the user for a title
and creates a new draft (with a slugged file name) in the blog's =_drafts/=
directory. The new post includes appropriate YAML header information.

This also defines =hrs/publish-post= and =hrs/unpublish-post=, which adjust the
date in the YAML front matter and rename the file appropriately.

#+begin_src emacs-lisp
  (defvar hrs/jekyll-drafts-directory "/home/hrs/documents/blog/_drafts/")
  (defvar hrs/jekyll-posts-directory "/home/hrs/documents/blog/_posts/")
  (defvar hrs/jekyll-post-extension ".md")

  (defun hrs/timestamp ()
    (format-time-string "%Y-%m-%d"))

  (defun hrs/replace-whitespace-with-hyphens (s)
    (replace-regexp-in-string " " "-" s))

  (defun hrs/replace-nonalphanumeric-with-whitespace (s)
    (replace-regexp-in-string "[^A-Za-z0-9 ]" " " s))

  (defun hrs/remove-quotes (s)
    (replace-regexp-in-string "[\'\"]" "" s))

  (defun hrs/replace-unusual-characters (title)
    "Remove quotes, downcase everything, and replace characters
  that aren't alphanumeric with hyphens."
    (hrs/replace-whitespace-with-hyphens
     (s-trim
      (downcase
       (hrs/replace-nonalphanumeric-with-whitespace
        (hrs/remove-quotes title))))))

  (defun hrs/slug-for (title)
    "Given a blog post title, return a convenient URL slug.
     Downcase letters and remove special characters."
    (let ((slug (hrs/replace-unusual-characters title)))
      (while (string-match "--" slug)
        (setq slug (replace-regexp-in-string "--" "-" slug)))
      slug))

  (defun hrs/jekyll-yaml-template (title)
    "Return the YAML header information appropriate for a blog
     post. Include the title, the current date, the post layout,
     and an empty list of tags."
    (concat
     "---\n"
     "title: " title "\n"
     "date:\n"
     "layout: post\n"
     "# mathjax: true\n"
     "# pdf_file: " (hrs/slug-for title) ".pdf\n"
     "tags: []\n"
     "---\n\n"))

  (defun hrs/new-blog-post (title)
    "Create a new blog draft in Jekyll."
    (interactive "sPost title: ")
    (let ((post (concat hrs/jekyll-drafts-directory
                        (hrs/slug-for title)
                        hrs/jekyll-post-extension)))
      (if (file-exists-p post)
          (find-file post)
        (find-file post)
        (insert (hrs/jekyll-yaml-template title)))))

  (defun hrs/jekyll-draft-p ()
    "Return true if the current buffer is a draft."
    (equal
     (file-name-directory (buffer-file-name (current-buffer)))
     hrs/jekyll-drafts-directory))

  (defun hrs/jekyll-published-p ()
    "Return true if the current buffer is a published post."
    (equal
     (file-name-directory (buffer-file-name (current-buffer)))
     hrs/jekyll-posts-directory))

  (defun hrs/publish-post ()
    "Move a draft post to the posts directory, rename it to include
  the date, reopen the new file, and insert the date in the YAML
  front matter."
    (interactive)
    (cond ((not (hrs/jekyll-draft-p))
           (message "This is not a draft post."))
          ((buffer-modified-p)
           (message "Can't publish post; buffer has modifications."))
          (t
           (let ((filename
                  (concat hrs/jekyll-posts-directory
                          (hrs/timestamp) "-"
                          (file-name-nondirectory
                           (buffer-file-name (current-buffer)))))
                 (old-point (point)))
             (rename-file (buffer-file-name (current-buffer))
                          filename)
             (kill-buffer nil)
             (find-file filename)
             (set-window-point (selected-window) old-point)
             (save-excursion
               (beginning-of-buffer)
               (replace-regexp "^date:$" (concat "date: " (hrs/timestamp))))
             (save-buffer)
             (message "Published post!")))))

  (defun hrs/unpublish-post ()
    "Move a published post to the drafts directory, rename it to
  exclude the date, reopen the new file, and remove the date in the
  YAML front matter."
    (interactive)
    (cond ((not (hrs/jekyll-published-p))
           (message "This is not a published post."))
          ((buffer-modified-p)
           (message "Can't publish post; buffer has modifications."))
          (t
           (let ((filename
                  (concat hrs/jekyll-drafts-directory
                          (substring
                           (file-name-nondirectory
                            (buffer-file-name (current-buffer)))
                           11 nil)))
                 (old-point (point)))
             (rename-file (buffer-file-name (current-buffer))
                          filename)
             (kill-buffer nil)
             (find-file filename)
             (set-window-point (selected-window) old-point)
             (save-excursion
               (beginning-of-buffer)
               (replace-regexp "^date: [0-9][0-9][0-9][0-9]-[0-9][0-9]-[0-9][0-9]$" "date:"))
             (save-buffer)
             (message "Returned post to drafts!")))))
#+end_src

This selects and inserts a tag:

#+begin_src emacs-lisp
  (defun hrs/existing-blog-tags ()
    "Return a list of all the tags currently used in my blog."
    (split-string (shell-command-to-string "cd ~/documents/blog && rake tags")))

  (defun hrs/insert-blog-tag ()
    "Prompt for one of the existing tags used in the blog and
  insert it in the YAML front matter appropriately."
    (interactive)
    (save-excursion
      (beginning-of-buffer)
      (search-forward-regexp "^tags: \\[")
      (insert
       (ivy-completing-read "Insert tag: " (hrs/existing-blog-tags))
       (if (looking-at "\\]") "" ", ")))
    (message "Tagged!"))
#+end_src

* Email with =mu4e=

Inconveniently, =mu4e= is distributed along with =mu= in my system's package
manager instead of as a package on MELPA. This loads up =mu4e= from the usual
location:

#+begin_src emacs-lisp
	(add-to-list 'load-path "/usr/share/emacs/site-lisp/mu4e")
  (require 'mu4e)
#+end_src

** Who am I?

I only have one context at the moment. If I had another email account, though,
I'd define it in here with an additional =make-mu4e-context= block.

My full name is defined earlier in this configuration file.

#+begin_src emacs-lisp
  (setq mu4e-contexts
        `(,(make-mu4e-context
            :name "personal"
            :match-func (lambda (msg)
                          (when msg
                            (string-prefix-p "/personal" (mu4e-message-field msg :maildir))))
            :vars '((user-mail-address . "hello@harryrschwartz.com")
                    (mu4e-trash-folder . "/personal/archive")
                    (mu4e-refile-folder . "/personal/archive")
                    (mu4e-sent-folder . "/personal/sent")
                    (mu4e-drafts-folder . "/personal/drafts")))))
#+end_src

Ordinarily =mu4e= would ask me which context I'd like to use, but since I've only
got the one, let's just default to that every time and avoid the prompt.

#+begin_src emacs-lisp
  (setq mu4e-context-policy 'pick-first)
#+end_src

** Fetching new mail

I fetch my email with a [[file:~/.dotfiles/bash/dot-bin/get-new-mail][custom script]] (though, in practice, I rarely fetch mail
manually; I have a cron job regularly calling the script to fetch my mail
asynchronously).

#+begin_src emacs-lisp
  (setq mu4e-get-mail-command "~/.bin/get-new-mail")
#+end_src

Rename files when moving them between directories. =mbsync= supposedly prefers
this; I'm cargo-culting.

#+begin_src emacs-lisp
  (setq mu4e-change-filenames-when-moving t)
#+end_src

I don't want to be interrupted with a new mail alert, but I'd also like to know
when I've got some. This adds an unobtrusive notification to my modeline and
updates it every minute.

#+begin_src emacs-lisp
  (use-package mu4e-alert
    :after mu4e
    :init
    (setq mu4e-alert-interesting-mail-query "flag:unread maildir:/personal/inbox")
    (mu4e-alert-enable-mode-line-display)
    (run-with-timer 0 60 'mu4e-alert-enable-mode-line-display))
#+end_src

** Viewing mail

I check my email pretty often! Probably more than I should. This binds =C-c m=
to close any other windows and open my personal inbox.

#+begin_src emacs-lisp
  (defun hrs/visit-inbox ()
    (interactive)
    (mu4e)
    (mu4e~headers-jump-to-maildir "/personal/inbox"))

  (global-set-key (kbd "C-c m") 'hrs/visit-inbox)
#+end_src

I don't really need to see the =*mu4e-main*= buffer (or, really, more than one
mu4e buffer of any kind at a time).

#+begin_src emacs-lisp
  (setq mu4e-split-view 'single-window)
#+end_src

I don't need to see the context of a thread (with all the deleted messages) in
my inbox.

#+begin_src emacs-lisp
  (setq mu4e-headers-include-related nil)
#+end_src

=mu4e= starts approximately instantaneously, so I don't know why I'd want to
reconsider quitting it.

#+begin_src emacs-lisp
  (setq mu4e-confirm-quit nil)
#+end_src

I'd rather word-wrap long lines when viewing mail.

#+begin_src emacs-lisp
  (add-hook 'mu4e-view-mode-hook 'visual-line-mode)
#+end_src

** Composing a new message

When I'm composing a new email, default to using the first context.

#+begin_src emacs-lisp
  (setq mu4e-compose-context-policy 'pick-first)
#+end_src

Compose new messages (as with =C-x m=) using =mu4e-user-agent=.

#+begin_src emacs-lisp
  (setq mail-user-agent 'mu4e-user-agent)
#+end_src

Once I've sent an email, kill the associated buffer instead of just burying it.

#+begin_src emacs-lisp
  (setq message-kill-buffer-on-exit t)
#+end_src

Write HTML emails in Org by toggling =org-msg-mode=.

I don't enable this by default because I usually prefer plain-text email, but
every now and then it's nice to be able to send a message with syntax
highlighting and LaTeX snippets (as PNGs) and all that fancy nonsense.

#+begin_src emacs-lisp
  (use-package org-msg
    :config
    (setq org-msg-options "html-postamble:nil H:5 num:nil ^:{} toc:nil author:nil email:nil tex:dvipng \\n:t"
          org-msg-startup "inlineimages"
          org-msg-greeting-fmt "\nHello, %s,\n\n"
          org-msg-greeting-name-limit 3
          org-msg-text-plain-alternative t
          org-msg-signature "

  Cheers,
  #+begin_signature
  Harry Schwartz
  #+end_signature"))
#+end_src

** Reading an email

Display the sender's email address along with their name.

#+begin_src emacs-lisp
  (setq mu4e-view-show-addresses t)
#+end_src

Save attachments in my =~/downloads= directory, not my home directory.

#+begin_src emacs-lisp
  (setq mu4e-attachment-dir "~/downloads")
#+end_src

Hit =C-c C-o= to open a URL in the browser.

#+begin_src emacs-lisp
  (define-key mu4e-view-mode-map (kbd "C-c C-o") 'mu4e~view-browse-url-from-binding)
#+end_src

While HTML emails are just fundamentally awful, we usually still need to read
them. This ensures that their formatting in Emacs isn't too hideous:

#+begin_src emacs-lisp
  (require 'mu4e-contrib)
  (setq mu4e-html2text-command 'mu4e-shr2text
        shr-color-visible-luminance-min 60
        shr-color-visible-distance-min 5
        shr-use-fonts nil
        shr-use-colors nil)
  (advice-add #'shr-colorize-region
              :around (defun shr-no-colourise-region (&rest ignore)))
#+end_src

But some HTML emails are just too messy to display in Emacs. This binds =a h= to
open the current email in my default Web browser.

#+begin_src emacs-lisp
  (add-to-list 'mu4e-view-actions
               '("html in browser" . mu4e-action-view-in-browser)
               t)
#+end_src

** Archiving mail

Marking a message for deletion applies the "Trashed" flag. This is unfortunate,
since Fastmail will automatically delete any messages with that flag (as is the
IMAP standard).

I want to archive my messages, not delete them, so I've rebound =d= to move
email to my "Archive" folder without applying that flag.

#+begin_src emacs-lisp
  (setq mu4e-maildir-shortcuts
      '(("/personal/archive" . ?A)))

  (fset 'hrs/mu4e-move-to-archive "mA")
  (evil-define-key 'normal mu4e-headers-mode-map (kbd "d") 'hrs/mu4e-move-to-archive)
  (evil-define-key 'normal mu4e-view-mode-map (kbd "d") 'hrs/mu4e-move-to-archive)
#+end_src

** Encryption

If a message is encrypted, my reply should always be encrypted, too.

#+begin_src emacs-lisp
  (defun hrs/encrypt-responses ()
    "Encrypt the current message if it's a reply to another encrypted message."
    (let ((msg mu4e-compose-parent-message))
      (when (and msg (member 'encrypted (mu4e-message-field msg :flags)))
          (mml-secure-message-encrypt-pgpmime))))

  (add-hook 'mu4e-compose-mode-hook 'hrs/encrypt-responses)
#+end_src

** Sending mail over SMTP

I send my email through =msmtp=. These settings describe how to send a message:

- Use a sendmail program instead of sending directly from Emacs,
- Tell =msmtp= to infer the correct account from the =From:= address,
- Don't add a "=-f username=" flag to the =msmtp= command, and
- Use =/usr/bin/msmtp=!

#+begin_src emacs-lisp
  (setq message-send-mail-function 'message-send-mail-with-sendmail)
  (setq message-sendmail-extra-arguments '("--read-envelope-from"))
  (setq message-sendmail-f-is-evil 't)
  (setq sendmail-program "msmtp")
#+end_src

** Agenda integration

=org-mu4e= lets me store links to emails. I use this to reference emails in my
TODO list while keeping my inbox empty.

#+begin_src emacs-lisp
  (require 'org-mu4e)
#+end_src

When storing a link to a message in the headers view, link to the message
instead of the search that resulted in that view.

#+begin_src emacs-lisp
  (setq org-mu4e-link-query-in-headers-mode nil)
#+end_src

** Configure =org-contacts= with =mu4e=

Use an =org-contacts= file to manage my address book.

 #+begin_src emacs-lisp
   (use-package org-contacts
     :ensure nil
     :after org
     :custom
     (org-contacts-files '("~/documents/contacts.org"))

     :config
     (setq mu4e-org-contacts-file (car org-contacts-files))
     (add-to-list 'mu4e-headers-actions
                  '("org-contact-add" . mu4e-action-add-org-contact) t)
     (add-to-list 'mu4e-view-actions
                  '("org-contact-add" . mu4e-action-add-org-contact) t))
 #+end_src

* RSS with =elfeed=

I use =elfeed= and =elfeed-org= to read my (300-odd!) feeds.

- Sort RSS feeds first by tag (=comics= come before =haskell=, for example), then by
  name of the feed, and finally by publication date.
- Increase the max number of simultaneous connections to 32.
- Open =elfeed= with =C-c r=.
- Load up my feeds from an Org file.

#+begin_src emacs-lisp
  (use-package elfeed
    :config
    (evil-define-key 'normal elfeed-show-mode-map (kbd "U") 'elfeed-show-tag--unread)

    (defun hrs/custom-elfeed-sort (a b)
      (let* ((a-tags (format "%s" (elfeed-entry-tags a)))
             (b-tags (format "%s" (elfeed-entry-tags b)))
             (a-title (elfeed-feed-title (elfeed-entry-feed a)))
             (b-title (elfeed-feed-title (elfeed-entry-feed b))))
        (if (string= a-tags b-tags)
            (if (string= a-title b-title)
                (< (elfeed-entry-date b) (elfeed-entry-date a))
              (string< b-title a-title))
          (string< a-tags b-tags))))
    (setf elfeed-search-sort-function #'hrs/custom-elfeed-sort)

    (elfeed-set-max-connections 32)

    (global-set-key (kbd "C-c r") 'elfeed))

  (use-package elfeed-org
    :config
    (progn
      (elfeed-org)
      (setq rmh-elfeed-org-files (list "~/documents/rss-feeds.org"))))
#+end_src

* Browsing the Web

I use Firefox to browse the Web, but I'd like to open [[https://gemini.circumlunar.space/][Gemini]] links in =elpher=.
This checks the prefix of each URL and uses the appropriate program to open it.

#+begin_src emacs-lisp
  (use-package elpher)

  (setq hrs/gemini-browser 'elpher-go)

  (defun hrs/browse-url (url &rest args)
    (if (s-prefix? "gemini:" url)
        (funcall hrs/gemini-browser url)
      (browse-url-default-browser url args)))

  (setq browse-url-browser-function 'hrs/browse-url)
#+end_src

Exporting Org files to HTML and opening the result triggers
=/usr/bin/sensible-browser=, which checks the =$BROWSER= environment variable to
choose the right browser. I'd like to always use Firefox for that, so:

#+begin_src emacs-lisp
  (setenv "BROWSER" "firefox")
#+end_src

** =engine-mode=

I sometimes use [[https://github.com/hrs/engine-mode][=engine-mode=]] to (mostly) look up error messages.

#+begin_src emacs-lisp
  (use-package engine-mode
    :config
    (engine-mode t)

    (defengine duckduckgo
      "https://duckduckgo.com/?q=%s"
      :keybinding "/"))
#+end_src

* Writing prose

I write prose in several modes: I might be editing an Org document, or a commit
message, or an email. These are the main ones, with sub-items being /derived/ from
their parents:

- =git-commit-mode=
- =text-mode=
  - =markdown-mode=
    - =gfm-mode=
  - =message-mode=
    - =mu4e-compose-mode=
  - =org-mode=

Recall that derived modes "inherit" their parent's hooks, so a hook added onto
e.g. =text-mode= will also be executed by =mu4e-compose-mode=.

There are some exceptions, but I can usually associate a hook with every
prose-related mode, so I store those in a list:

#+begin_src emacs-lisp
  (defvar prose-modes
    '(gfm-mode
      git-commit-mode
      markdown-mode
      message-mode
      mu4e-compose-mode
      org-mode
      text-mode))

  (defvar prose-mode-hooks
    (mapcar (lambda (mode) (intern (format "%s-hook" mode)))
            prose-modes))
#+end_src

** Use =variable-pitch= fonts when writing prose

I've been writing prose in a monospace font for at least fifteen years now. And,
y'know what? It's just not sparking joy.

I've recently started using a variable-pitch font for prose, and it's quite
nice! This ensures that that happens everywhere it's appropriate.

Yes, that even includes git commit messages! They're as much prose as a README
is, right?

#+begin_src emacs-lisp
  (defun hrs/enable-variable-pitch-mode ()
    (variable-pitch-mode 1))

  (dolist (hook prose-mode-hooks)
    (add-hook hook 'hrs/enable-variable-pitch-mode))

  (add-hook 'elfeed-show-mode-hook 'hrs/enable-variable-pitch-mode)
  (add-hook 'elpher-mode-hook 'hrs/enable-variable-pitch-mode)
  (add-hook 'mu4e-view-mode-hook 'hrs/enable-variable-pitch-mode)
#+end_src

That said, code, links, and tables in Org should still be monospaced. They look
kinda goofy otherwise, I think.

#+begin_src emacs-lisp
  (add-hook 'org-mode-hook
            (lambda ()
              (set-face-attribute 'org-block nil :inherit 'fixed-pitch)
              (set-face-attribute 'org-code nil :inherit 'fixed-pitch)
              (set-face-attribute 'org-table nil :inherit 'fixed-pitch)
              (set-face-attribute 'org-verbatim nil :inherit 'fixed-pitch)))
#+end_src

The same is true for =crontab= files (which derive from =text-mode=, apparently!):

#+begin_src emacs-lisp
  (add-hook 'crontab-mode-hook
            (lambda () (variable-pitch-mode 0)))
#+end_src

** Enable spell-checking in the usual places

I want to make sure that I've enabled spell-checking if I'm editing text,
composing an email, or authoring a Git commit.

#+begin_src emacs-lisp
  (use-package flyspell
    :ensure-system-package ispell
    :config
    (setq ispell-personal-dictionary "~/.ispell_words")
    (dolist (hook prose-mode-hooks)
      (add-hook hook 'flyspell-mode)))
#+end_src

** Wrap paragraphs automatically

=AutoFillMode= automatically wraps paragraphs, kinda like hitting =M-q=. I wrap a
lot of paragraphs, so this automatically wraps 'em when I'm writing text,
Markdown, or Org.

#+begin_src emacs-lisp
  (dolist (hook prose-mode-hooks)
    (add-hook hook 'turn-on-auto-fill))
#+end_src

** Use Org-style lists and tables everywhere

Enable Org-style tables.

#+begin_src emacs-lisp
  (add-hook 'git-commit-mode-hook 'orgtbl-mode)
  (add-hook 'markdown-mode-hook 'orgtbl-mode)
  (add-hook 'message-mode-hook 'orgtbl-mode)
#+end_src

Use the [[https://elpa.gnu.org/packages/orgalist.html][=orgalist=]] package for more convenient list manipulation.

#+begin_src emacs-lisp
  (use-package orgalist
    :hook ((git-commit-mode markdown-mode message-mode) . orgalist-mode))
#+end_src

** Linting prose

I've been using [[https://github.com/errata-ai/vale][vale]] as a prose linter, and it's not been bad so far. There's a
package that integrates it with =flycheck=, but it doesn't seem to work, so I've
got some code here to do it manually.

#+begin_src emacs-lisp
  (flycheck-define-checker vale
    "A checker for prose"
    :command ("vale" "--output" "line"
              source)
    :standard-input nil
    :error-patterns
    ((error line-start (file-name) ":" line ":" column ":" (id (one-or-more (not (any ":")))) ":" (message) line-end))
    :modes prose-modes)

  (add-to-list 'flycheck-checkers 'vale 'append)
#+end_src

** Activate =prose-assistant-mode=

I wrote [[file:resources/prose-assistant-mode.el][this global minor mode]] to let me quickly trigger a handful of common
tools I reach for while writing prose (dictionaries, word counting, etymologies,
spellchecking, translation, that sort of thing).

#+begin_src emacs-lisp
  (require 'prose-assistant-mode)
  (prose-assistant-mode t)
#+end_src

** Editing with Markdown

Because I can't always use =org=.

- Associate =.md= files with GitHub-flavored Markdown.
- Use =pandoc= to render the results.
- Apply syntax highlighting in code blocks.

#+begin_src emacs-lisp
  (use-package markdown-mode
    :ensure-system-package pandoc
    :commands gfm-mode
    :mode (("\\.md$" . gfm-mode))
    :config
    (custom-set-faces
     '(markdown-pre-face ((t nil))))

    (setq markdown-command "pandoc --standalone --mathjax --from=markdown"
          markdown-disable-tooltip-prompt t
          markdown-fontify-code-blocks-natively t))
#+end_src

** Cycle between spacing alternatives

Successive calls to =cycle-spacing= rotate between changing the whitespace
around point to:

- A single space,
- No spaces, or
- The original spacing.

Binding this to =M-SPC= is strictly better than the original binding of
=just-one-space=.

#+begin_src emacs-lisp
  (global-set-key (kbd "M-SPC") 'cycle-spacing)
#+end_src

** Enable region case modification

#+begin_src emacs-lisp
  (put 'downcase-region 'disabled nil)
  (put 'upcase-region 'disabled nil)
#+end_src

* File management with =dired=

I've started using =dired= as my primary file manager. About time, huh?

- Set some specific =ls= switches:
  - Use the long listing format.
  - Sort numbers naturally.
  - Don't include the owner or group names.
  - Use human-readable sizes.
  - Format timestamps as =YYYY-MM-DD=.
  - Include hidden files, but /don't/ include "=.=" or "=..=".
- Kill buffers of files/directories that are deleted in =dired=.
- When I've got two =dired= windows side-by-side, and I move or copy files in one
  window, set the default location to the other window.
- Always copy directories recursively instead of asking every time.
- Do please ask before recursively /deleting/ a directory, though.
- Enable =auto-revert-mode= in =dired= buffers (so when a directory's contents are
  modified the results are reflected in the buffer automatically).

I'm often browsing directories of photos and images, so this also binds "=v=" to
view a slideshow of the current directory with =s= (a custom =feh= wrapper [[file:~/.dotfiles/bash/dot-bin/s][defined
elsewhere in this repo]]).

#+begin_src emacs-lisp
  (use-package dired
    :ensure nil

    :config
    (defun hrs/dired-slideshow ()
      (interactive)
      (start-process "dired-slideshow" nil "s" (dired-current-directory)))

    (evil-define-key 'normal dired-mode-map (kbd "o") 'dired-find-file-other-window)
    (evil-define-key 'normal dired-mode-map (kbd "v") 'hrs/dired-slideshow)

    (setq-default dired-listing-switches
                  (combine-and-quote-strings '("-l"
                                               "-v"
                                               "-g"
                                               "--no-group"
                                               "--human-readable"
                                               "--time-style=+%Y-%m-%d"
                                               "--almost-all")))
    (setq dired-clean-up-buffers-too t
          dired-dwim-target t
          dired-recursive-copies 'always
          dired-recursive-deletes 'top
          global-auto-revert-non-file-buffers t))
#+end_src

Hide dotfiles by default, but toggle their visibility with "=.=". This conflicts
with =evil-repeat=, but in practice I never use that with =dired=, so the mnemonic
is worth it for me.

#+begin_src emacs-lisp
  (use-package dired-hide-dotfiles
    :config
    (dired-hide-dotfiles-mode 1)
    (evil-define-key 'normal dired-mode-map "." 'dired-hide-dotfiles-mode))
#+end_src

Open media with the appropriate programs.

#+begin_src emacs-lisp
  (use-package dired-open
    :ensure-system-package (abiword
                            feh
                            (ffplay . ffmpeg)
                            gnumeric
                            mpv
                            zathura)
    :config
    (setq dired-open-extensions
          '(("avi" . "mpv")
            ("cbr" . "zathura")
            ("doc" . "abiword")
            ("docx" . "abiword")
            ("gif" . "ffplay")
            ("gnumeric" . "gnumeric")
            ("jpeg" . "s")
            ("jpg" . "s")
            ("mkv" . "mpv")
            ("mov" . "mpv")
            ("mp3" . "mpv")
            ("mp4" . "mpv")
            ("pdf" . "zathura")
            ("png" . "s")
            ("webm" . "mpv")
            ("xls" . "gnumeric")
            ("xlsx" . "gnumeric"))))
#+end_src

Files are normally moved and copied synchronously. This is fine for small or
local files, but copying a large file or moving a file across a mounted network
drive blocks Emacs until the process is completed. Unacceptable!

This uses =emacs-async= to make =dired= perform actions asynchronously.

#+begin_src emacs-lisp
  (use-package async
    :config
    (dired-async-mode 1))
#+end_src

* Editing settings

** Quickly visit Emacs configuration

I futz around with my dotfiles a lot. This binds =C-c e= to quickly open my
Emacs configuration file.

#+begin_src emacs-lisp
  (defun hrs/visit-emacs-config ()
    (interactive)
    (find-file (concat user-emacs-directory "configuration.org")))

  (global-set-key (kbd "C-c e") 'hrs/visit-emacs-config)
#+end_src

** Always kill current buffer

Assume that I always want to kill the current buffer when hitting =C-x k=.

#+begin_src emacs-lisp
  (defun hrs/kill-current-buffer ()
    "Kill the current buffer without prompting."
    (interactive)
    (kill-buffer (current-buffer)))

  (global-set-key (kbd "C-x k") 'hrs/kill-current-buffer)
#+end_src

** Set up =helpful=

The =helpful= package provides, among other things, more context in Help
buffers.

#+begin_src emacs-lisp
  (use-package helpful)

  (global-set-key (kbd "C-h f") #'helpful-callable)
  (global-set-key (kbd "C-h v") #'helpful-variable)
  (global-set-key (kbd "C-h k") #'helpful-key)
  (evil-define-key 'normal helpful-mode-map (kbd "q") 'quit-window)
#+end_src

** Look for executables in =/usr/local/bin=

#+begin_src emacs-lisp
  (hrs/append-to-path "/usr/local/bin")
#+end_src

** Save my location within a file

Using =save-place-mode= saves the location of point for every file I visit. If I
close the file or close the editor, then later re-open it, point will be at the
last place I visited.

#+begin_src emacs-lisp
  (setq save-place-forget-unreadable-files nil)
  (save-place-mode 1)
#+end_src

** Always indent with spaces

Never use tabs. Tabs are the devil’s whitespace.

#+begin_src emacs-lisp
  (setq-default indent-tabs-mode nil)
#+end_src

** Install and configure =which-key=

=which-key= displays the possible completions for a long keybinding. That's
really helpful for some modes (like =projectile=, for example).

#+begin_src emacs-lisp
  (use-package which-key
    :config (which-key-mode))
#+end_src

** Configure =yasnippet=

I always want =yasnippet= enabled.

I /don’t/ want =yas= to always indent the snippets it inserts. Sometimes this looks
pretty bad (when indenting =org-mode=, for example, or trying to guess at the
correct indentation for Python).

#+begin_src emacs-lisp
  (use-package yasnippet
    :config
    (setq yas-indent-line 'auto)
    (yas-global-mode 1))
#+end_src

** Configure =ivy= and =counsel=

I use =ivy= and =counsel= as my completion framework.

This configuration:

- Uses =counsel-M-x= for command completion,
- Replaces =isearch= with =swiper=,
- Uses =smex= to maintain history,
- Enables fuzzy matching everywhere except swiper (where it's thoroughly
  unhelpful), and
- Includes recent files in the switch buffer.

#+begin_src emacs-lisp
  (use-package counsel
    :bind
    ("M-x" . 'counsel-M-x)
    ("C-s" . 'swiper)

    :config
    (use-package flx)
    (use-package smex)

    (ivy-mode 1)
    (setq ivy-use-virtual-buffers t)
    (setq ivy-count-format "(%d/%d) ")
    (setq ivy-initial-inputs-alist nil)
    (setq ivy-re-builders-alist
          '((swiper . ivy--regex-plus)
            (t . ivy--regex-fuzzy))))
#+end_src

Add pretty icons and descriptions to the =ivy= buffer.

#+begin_src emacs-lisp
  (use-package ivy-rich
    :init
    (ivy-rich-mode 1))

  (use-package all-the-icons-ivy-rich
    :init
    (all-the-icons-ivy-rich-mode 1))
#+end_src

** Switch and rebalance windows when splitting

When splitting a window, I invariably want to switch to the new window. This
makes that automatic. Similarly, when closing a window I'd like to rebalance the
remaining windows.

#+begin_src emacs-lisp
  (defun hrs/split-window-below-and-switch ()
    "Split the window horizontally, then switch to the new pane."
    (interactive)
    (split-window-below)
    (balance-windows)
    (other-window 1))

  (defun hrs/split-window-right-and-switch ()
    "Split the window vertically, then switch to the new pane."
    (interactive)
    (split-window-right)
    (balance-windows)
    (other-window 1))

  (defun hrs/delete-window-and-rebalance ()
    "Delete the current window, then rebalance the remaining windows."
    (interactive)
    (delete-window)
    (balance-windows))

  (global-set-key (kbd "C-x 2") 'hrs/split-window-below-and-switch)
  (global-set-key (kbd "C-x 3") 'hrs/split-window-right-and-switch)
  (global-set-key (kbd "C-x 0") 'hrs/delete-window-and-rebalance)
#+end_src

** Mass editing of =grep= results

I like the idea of mass editing =grep= results the same way I can edit filenames
in =dired=. These keybindings allow me to use =C-x C-q= to start editing =grep=
results and =C-c C-c= to stop, just like in =dired=.

#+begin_src emacs-lisp
  (use-package wgrep)

  (eval-after-load 'grep
    '(define-key grep-mode-map
      (kbd "C-x C-q") 'wgrep-change-to-wgrep-mode))

  (eval-after-load 'wgrep
    '(define-key grep-mode-map
      (kbd "C-c C-c") 'wgrep-finish-edit))

  (setq wgrep-auto-save-buffer t)
#+end_src

* Set custom keybindings

Just a few handy functions.

#+begin_src emacs-lisp
  (global-set-key (kbd "C-w") 'backward-kill-word)
  (global-set-key (kbd "M-o") 'other-window)
  (global-set-key (kbd "C-x C-b") 'ibuffer)
#+end_src

Remap when working in terminal Emacs.

#+begin_src emacs-lisp
  (define-key input-decode-map "\e[1;2A" [S-up])
#+end_src

* Extra

#+begin_src emacs-lisp
  (load-file "~/.emacs-private.el")
#+end_src

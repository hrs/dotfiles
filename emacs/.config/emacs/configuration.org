#+title: Emacs Configuration
#+author: Harry R. Schwartz
#+email: hello@harryrschwartz.com
#+options: toc:nil num:nil

* Configure =use-package=

I use =use-package= to install and configure my packages. My =init.el= includes the
initial setup for =package.el= and ensures that =use-package= is installed, since I
wanna do that right away.

This makes sure that =use-package= will install the package if it's not already
available. It also means that I should be able to open Emacs for the first time
on a fresh Debian box and have my whole environment automatically installed. I'm
not /totally/ sure about that, but we're gettin' close.

#+begin_src emacs-lisp
  (require 'use-package-ensure)
  (setq use-package-always-ensure t)
#+end_src

Defer loading packages unless explicitly demanded.

#+begin_src emacs-lisp
  (setq use-package-always-defer t)
#+end_src

Always compile packages, and use the newest version available.

#+begin_src emacs-lisp
	(use-package auto-compile
		:demand t
		:config (auto-compile-on-load-mode))

	(setq load-prefer-newer t)
#+end_src

Disable deprecation warnings about =cl=. The =cl= library has been deprecated, but
lots of packages still use it. I can't control that, but I can disable the
warnings.

#+begin_src emacs-lisp
  (setq byte-compile-warnings '(cl-functions))
#+end_src

If an Emacs package relies on the installation of a system package, install that
package (for example, =deadgrep= doesn't work if =ripgrep= isn't installed). This
uses the system package manager (Debian's =apt=, in my case).

#+begin_src emacs-lisp
  (use-package use-package-ensure-system-package
		:demand t
    :custom
    (system-packages-package-manager 'apt))
#+end_src

Don't pop up a buffer to warn me about deprecations and other minor issues.

#+begin_src emacs-lisp
  (setq warning-minimum-level :emergency)
#+end_src

* Use =sensible-defaults.el=

Use [[https://github.com/hrs/sensible-defaults.el][sensible-defaults.el]] for some basic settings.

#+begin_src emacs-lisp
	(use-package sensible-defaults
		:load-path "~/code/personal/sensible-defaults.el"
		:demand t

		:config
		(sensible-defaults/use-all-settings)
		(sensible-defaults/use-all-keybindings)
		(sensible-defaults/backup-to-temp-directory))
#+end_src

Trigger garbage collection when I've been idle for five seconds and memory usage
is over 16 MB.

#+begin_src emacs-lisp
	(use-package gcmh
		:demand t

		:init
		(setq gcmh-idle-delay 5
					gcmh-high-cons-threshold (* 16 1024 1024))
		:config
		(gcmh-mode))
#+end_src

* =evil-mode=

Load and configure =evil-mode=.

- I'd prefer not to expand abbrevs when I hit escape. That's always jarring and
  usually not what I want. In particular, it makes working with Coq really
  frustrating.
- Don't automatically load Evil bindings in different modes.
- Bind =C-p= to fuzzy-finding files in the current project. We also need to
  explicitly set that in a few other modes.

#+begin_src emacs-lisp
  (use-package evil
    :demand t

    :init
    (setq evil-respect-visual-line-mode t
          evil-want-abbrev-expand-on-insert-exit nil
          evil-want-keybinding nil)

    :config
    (evil-mode 1)

    (evil-define-key '(normal insert) 'global (kbd "C-p") 'project-find-file)

    (evil-define-key 'normal org-mode-map (kbd "TAB") 'org-cycle)
    (evil-define-key 'insert org-mode-map (kbd "S-<right>") 'org-shiftright)
    (evil-define-key 'insert org-mode-map (kbd "S-<left>") 'org-shiftleft)

    (fset 'evil-visual-update-x-selection 'ignore))
#+end_src

Install =evil-collection=, which provides evil-friendly bindings for many modes.

#+begin_src emacs-lisp
  (use-package evil-collection
    :after evil
    :demand t

    :config
    (setq evil-collection-mode-list
          '(comint
            deadgrep
            dired
            elfeed
            eww
            ibuffer
            info
            magit
            mu4e
            package-menu
            pdf-view
            proced
            replace
            vterm
            which-key))

    (evil-collection-init))
#+end_src

Enable =surround= everywhere.

#+begin_src emacs-lisp
  (use-package evil-surround
    :after evil
    :demand t
    :config
    (global-evil-surround-mode 1))
#+end_src

Use =evil= with Org agendas.

#+begin_src emacs-lisp
  (use-package evil-org
    :after (evil org)
    :demand t

    :config
    (require 'evil-org-agenda)
    (evil-org-agenda-set-keys))
#+end_src

* Extend the =exec-path= and =PATH= as needed

#+begin_src emacs-lisp
  (defun +append-to-path (path)
    "Add a path both to the $PATH variable and to Emacs' exec-path."
    (setenv "PATH" (concat (getenv "PATH") ":" path))
    (add-to-list 'exec-path path))

  (setq +local-bin-paths
        '("/usr/local/bin"
          "~/.bin"
          "~/bin"
          "~/.cargo/bin"
          "~/.cabal/bin"
          "~/.opam/default/bin"
          "~/.local/bin"))

  (dolist (path +local-bin-paths)
    (+append-to-path (expand-file-name path)))
#+end_src

* Utility functions

Define a big ol' bunch of handy utility functions.

#+begin_src emacs-lisp
  (defun +visit-last-migration ()
    "Open the most recent Rails migration."
    (interactive)
    (let ((migrations
           (directory-files
            (expand-file-name "db/migrate" (project-root (project-current))) t)))
      (find-file (car (last migrations)))))

  (defun +image-path-p (path)
    "Return true if the path corresponds to an image file."
    (member (downcase (or (file-name-extension path) ""))
            '("bmp" "gif" "jpeg" "jpg" "png" "tiff")))
#+end_src

* UI preferences

** Don't resize the frame

By default, Emacs attempts to resize each frame to maintain a certain number of
characters in each line, so this width varies depending on the font used. This
operation is a bit expensive, and since I use =i3=, a tiling window manager, it's
also completely unnecessary, since the frame will be resized differently
regardless. Just skip the whole thing instead.

#+begin_src emacs-lisp
  (setq frame-inhibit-implied-resize t)
#+end_src

** Tweak window chrome

I don't usually use the menu or scroll bar, and they take up useful space.

#+begin_src emacs-lisp
  (tool-bar-mode 0)
  (menu-bar-mode 0)
  (scroll-bar-mode -1)
#+end_src

There's a tiny scroll bar that appears in the minibuffer window. This disables
that:

#+begin_src emacs-lisp
  (set-window-scroll-bars (minibuffer-window) nil nil)
#+end_src

** Enable smooth scrolling

This is especially nice when I've got a document with embedded images or
rendered equations. Or on the rare occasions I use a mouse.

In certain read-only modes I like to bind =J= and =K= to scrolling. That's nice
for reading mail or RSS items. This provides a =+bind-scroll-keys= function I
can use to enable that for a given key map.

#+begin_src emacs-lisp
  (pixel-scroll-precision-mode 1)

  (defvar +scroll-delta 180)

  (defun +scroll-up-some ()
    (interactive)
    (pixel-scroll-precision-scroll-up +scroll-delta))

  (defun +scroll-down-some ()
    (interactive)
    (pixel-scroll-precision-scroll-down +scroll-delta))

  (defun +bind-scroll-keys (mode-map)
    (evil-define-key '(motion normal) mode-map (kbd "K") '+scroll-up-some)
    (evil-define-key '(motion normal) mode-map (kbd "J") '+scroll-down-some))
#+end_src

** Use fancy lambdas

Why not?

#+begin_src emacs-lisp
  (global-prettify-symbols-mode t)
#+end_src

** Configure a pretty modeline

#+begin_src emacs-lisp
  (use-package moody
    :demand t

    :custom
    (x-underline-at-descent-line t)
    :config
    (moody-replace-mode-line-buffer-identification)
    (moody-replace-vc-mode))
#+end_src

** Load up a theme

This sets up the current theme.

#+begin_src emacs-lisp
  (use-package ef-themes
    :custom
     (ef-themes-headings
           '((0 . (1.3))
             (1 . (1.3))
             (2 . (1.2))
             (t . (1.1))))
     (ef-themes-mixed-fonts t))

  (ef-themes-select 'ef-light)
#+end_src

** Use =minions= to hide all minor modes

I never want to see a minor mode, and manually adding =:diminish= to every
use-package declaration is a hassle. This uses =minions= to hide all the minor
modes in the modeline. Nice!

#+begin_src emacs-lisp
  (use-package minions
    :demand t

    :custom
    (minions-mode-line-delimiters (cons "" ""))

    :config
    (defun +set-minions-mode-line-lighter ()
      (setq minions-mode-line-lighter
            (if (display-graphic-p) "⚙" "#")))

    (add-hook 'server-after-make-frame-hook #'+set-minions-mode-line-lighter)

    (minions-mode 1))
#+end_src

** Scroll conservatively

When point goes outside the window, Emacs usually recenters the buffer point.
I'm not crazy about that. This changes scrolling behavior to only scroll as far
as point goes.

#+begin_src emacs-lisp
  (setq scroll-conservatively 100)
#+end_src

** Set font and configure font resizing

#+begin_src emacs-lisp
  (set-face-attribute 'default nil
                      :family "Fantasque Sans Mono"
                      :height 70)

  (set-face-attribute 'fixed-pitch nil
                      :family "Fantasque Sans Mono"
                      :height 70)

  (set-face-attribute 'variable-pitch nil
                      :family "ETBembo"
                      :height 70)

  (use-package default-text-scale
    :bind
    (("C-)" . default-text-scale-reset)
     ("C-=" . default-text-scale-increase)
     ("C--" . default-text-scale-decrease)))
#+end_src

** Highlight the current line

=global-hl-line-mode= softly highlights the background color of the line
containing point. It makes it a bit easier to find point, and it's useful when
pairing or presenting code.

#+begin_src emacs-lisp
  (when (display-graphic-p)
    (global-hl-line-mode))
#+end_src

** Highlight uncommitted changes

Use the =diff-hl= package to highlight changed-and-uncommitted lines when
programming.

#+begin_src emacs-lisp
  (use-package diff-hl
    :config
    :hook ((text-mode prog-mode vc-dir-mode) . turn-on-diff-hl-mode))
#+end_src

* Project management

I use a few packages in virtually every programming or writing environment to
manage the project, handle auto-completion, search for terms, and deal with
version control. That's all in here.

** =ripgrep=

Install =ripgrep= to provide search within projects. Search even "hidden"
dotfiles, but not =.git= repos.

#+begin_src emacs-lisp
  (use-package deadgrep
    :ensure-system-package (rg . ripgrep)
    :commands (deadgrep deadgrep--read-search-term)

    :config
    (evil-define-key 'motion deadgrep-mode-map (kbd "C-p") 'project-find-file)

    (defun deadgrep--include-args (rg-args)
      (push "--hidden" rg-args)
      (push "--glob=!.git/" rg-args))
    (advice-add 'deadgrep--arguments
                :filter-return #'deadgrep--include-args))
#+end_src

** =comint=

Treat =comint= sessions more like a shell.

#+begin_src emacs-lisp
  (use-package comint-mode
    :ensure nil
    :bind ("C-l" . comint-clear-buffer)

    :config
    (evil-define-key '(normal insert) comint-mode-map (kbd "C-d") '+kill-current-buffer))
#+end_src

** =company=

Use =company-mode= everywhere.

#+begin_src emacs-lisp
  (use-package company
    :hook (prog-mode . company-mode)
    :bind (:map company-active-map
                ("<tab>" . company-complete-selection))

    :custom
    (company-backends '((company-capf company-dabbrev-code)))
    (company-idle-delay 0.2)
    (company-minimum-prefix-length 5)
    (company-tooltip-align-annotations t)
    (company-tooltip-limit 20)

    :config
    (setq lsp-completion-provider :capf))
#+end_src

** =docker=

I use [[https://www.docker.com/][Docker]] less often than you might expect for a person who mostly does Web
development, but when I do [[https://github.com/Silex/docker.el][=docker.el=]] provides a convenient, =magit=-like
interface for managing containers.

#+begin_src emacs-lisp
  (use-package docker
    :ensure-system-package docker)
#+end_src

** =dumb-jump=

The =dumb-jump= package works well enough in a [[https://github.com/jacktasia/dumb-jump#supported-languages][ton of environments]], and it doesn't
require any additional setup. I've bound its most useful command to =M-.=.

#+begin_src emacs-lisp
  (use-package dumb-jump
    :demand t

    :init
    (setq xref-show-definitions-function #'xref-show-definitions-completing-read)

    :custom
    (xref-search-program 'ripgrep)

    :config
    (add-hook 'xref-backend-functions #'dumb-jump-xref-activate)
    (define-key evil-normal-state-map (kbd "M-.") 'xref-find-definitions))
#+end_src

The =xref-find-definitions= function creates an =XREF= buffer of results if more
than one thing matches. That's inconvenient; I'd rather use Ivy to select among
them.

#+begin_src emacs-lisp
  (use-package ivy-xref
    :demand t

    :custom
    (xref-show-definitions-function #'ivy-xref-show-defs))
#+end_src

** =flycheck=

I'd like to enable =flycheck= all kinds of places, but I don't really need the
keybindings (and they conflict with, for example, the default =C-c != binding for
=org-time-stamp-inactive=).

#+begin_src emacs-lisp
  (use-package flycheck
    :demand t

    :config
    (unbind-key "C-c !" flycheck-mode-map)
    (global-flycheck-mode))
#+end_src

** =magit=

I use =magit= to handle version control. It's lovely, but I tweak a few things:

- I bring up the status menu with =C-x g=.
- The default behavior of =magit= is to ask before pushing. I haven't had any
  problems with accidentally pushing, so I'd rather not confirm that every time.
- Per [[http://tbaggery.com/2008/04/19/a-note-about-git-commit-messages.html][tpope's suggestions]], highlight commit text in the summary line that goes
  beyond 50 characters.
- I'd like to start in the insert state when writing a commit message.

#+begin_src emacs-lisp
  (use-package magit
    :ensure-system-package git
    :hook (with-editor-mode . evil-insert-state)
    :bind ("C-x g" . magit-status)

    :config
    (use-package git-commit)
    (use-package magit-section)
    (use-package with-editor)

    (require 'git-rebase)

    (setq magit-push-always-verify nil
          git-commit-summary-max-length 50))
#+end_src

I'm also partial to =git-timemachine=, which lets you quickly page through the
history of a file.

#+begin_src emacs-lisp
  (use-package git-timemachine)
#+end_src

** =project.el=

- Bind searching within the project to =C-c v=.
- Treat a directory containing =.dir-locals.el= as a project root (useful for
  projects not under version control).
- When I switch projects, just open a =dired= buffer at the project root rather
  than asking whether I want to open a file, search, etc.

#+begin_src emacs-lisp
  (use-package project
    :bind (("C-c v" . deadgrep)
           ("C-x p p" . +project-switch-project))

    :custom
    (project-vc-extra-root-markers '(".dir-locals.el"))

    :config
    (defun +project-switch-project (dir)
      (interactive (list (project-prompt-project-dir)))
      (dired dir)))
#+end_src

** =codespaces=

I use GitHub Codespaces for a few projects.

#+begin_src emacs-lisp
  (use-package codespaces
    :ensure-system-package gh
    :demand t
    :config
    (setq vc-handled-backends '(Git))
    (codespaces-setup))
#+end_src

** =undo-tree=

I like tree-based undo management. I only rarely need it, but when I do, oh boy.

This configuration:

- Stores all undo files under the =undo-tree= directory in my Emacs config
  directory.
- Registers =undo-tree= for use in =evil-mode=.
- Suppresses warnings about being unable to load undo history when an underlying
  file is changed outside Emacs (as often happens when I, say, append a task to
  my todo lists through a script).

#+begin_src emacs-lisp
  (use-package undo-tree
    :demand t

    :config
    (setq undo-tree-history-directory-alist `(("." . ,(concat user-emacs-directory "undo-tree"))))
    (global-undo-tree-mode)
    (evil-set-undo-system 'undo-tree)

    (defun +undo-tree-suppress-undo-history-saved-message (undo-tree-save-history &rest args)
      "Suppress the message saying that the undo history file was saved (because this happens every single time you save a file)."
      (let ((inhibit-message t))
        (apply undo-tree-save-history args)))

    (defun +undo-tree-suppress-buffer-modified-message (undo-tree-load-history &rest args)
      "Suppress the message saying that the undo history could not be loaded because the file changed outside of Emacs."
      (let ((inhibit-message t))
        (apply undo-tree-load-history args)))

    (advice-add #'undo-tree-load-history :around
                #'+undo-tree-suppress-undo-history-saved-message)

    (advice-add #'undo-tree-load-history :around
                #'+undo-tree-suppress-buffer-modified-message))
#+end_src

** ChatGPT integration

I've been toying around with integrating ChatGPT into my work. =org-ai= enables
that by providing =begin_ai= blocks in Org which interact with ChatGPT sessions.

Authentication is handled by an auth key for =api.openai.com= in my =.netrc=, which
=org-ai= knows to read. I've also got a pair of snippets to create [[file:snippets/org-mode/ai][conversations]]
and [[file:snippets/org-mode/dalle][images]].

#+begin_src emacs-lisp
  (use-package org-ai
    :commands (org-ai-mode)
    :hook (org-mode . org-ai-mode)

    :custom
    (org-ai-image-directory (expand-file-name "~/media/pictures/ai")))
#+end_src

An [[https://github.com/xenodium/chatgpt-shell][interactive shell session]] is often even more useful.

#+begin_src emacs-lisp
  (use-package chatgpt-shell
    :commands (chatgpt-shell)

    :custom
    (chatgpt-shell-openai-key (auth-source-pick-first-password :host "api.openai.com")))
#+end_src

* Programming environments

I like shallow indentation, but tabs are displayed as 8 characters by default.
This reduces that.

#+begin_src emacs-lisp
  (setq-default tab-width 2)
#+end_src

Treating terms in CamelCase symbols as separate words makes editing a little
easier for me, so I like to use =subword-mode= everywhere.

#+begin_src emacs-lisp
  (use-package subword
    :config (global-subword-mode 1))
#+end_src

Compilation output goes to the =*compilation*= buffer. I rarely have that window
selected, so the compilation output disappears past the bottom of the window.
This automatically scrolls the compilation window so I can always see the
output.

#+begin_src emacs-lisp
  (setq compilation-scroll-output t)
#+end_src

I use LSP for some languages. This hooks LSP to run in those modes and ensures
that it displays all available documentation on hover.

#+begin_src emacs-lisp
  (use-package lsp-mode
    :commands (lsp lsp-deferred)
    :hook ((go-mode ruby-mode) . lsp-deferred)

    :custom
    (lsp-eldoc-render-all t))
#+end_src

This integrates LSP into my UI in various useful ways. Specifically, it writes
documentation and type annotations and suchlike all over my damn screen, which /I/
enjoy, personally.

#+begin_src emacs-lisp
  (use-package lsp-ui
    :commands lsp-ui-mode
    :hook (lsp-mode . lsp-ui-mode)

    :custom
    (lsp-ui-peek-always-show t)
    (lsp-ui-sideline-show-hover t)
    (lsp-ui-doc-enable nil))
#+end_src

** Coq

I use [[https://proofgeneral.github.io/][Proof General]] as my Coq IDE.

- I like to disable =abbrev-mode=; it has a ton of abbreviations for Coq, but
  they've always been unpleasant surprises for me.
- Similarly, =flycheck-mode= seems to do more harm than good.
- The Proof General splash screen's pretty cute, but I don't need to see it
  every time.
- The default Proof General layout stacks the code, goal, and response buffers
  on top of each other. I like to keep my code on one side and my goal and
  response buffers on the other.
- Have point follow the end of the locked region when asserting and undoing
  proof commands, but don't lock it to the end.
- Proof General usually evaluates each comment individually. In literate
  programs, this can result in evaluating a /ton/ of comments. This evaluates a
  series of consecutive comments as a single comment.

#+begin_src emacs-lisp
  (use-package proof-general
    :ensure-system-package (coqc . coq)
    :hook (coq-mode . (lambda ()
                        (undo-tree-mode 1)
                        (abbrev-mode 0)
                        (flycheck-mode 0)))
    :bind ("C-c v" . deadgrep)

    :custom
    (proof-splash-enable nil)
    (proof-three-window-mode-policy 'hybrid)
    (proof-follow-mode 'follow)
    (proof-script-fly-past-comments t))
#+end_src

=company-coq-mode= adds some features (completion, documentation, ligatures...)
which make Proof General a bit friendlier.

I bind the up and down arrow keys to evaluating and retracting the next and
previous statements. This is more convenient for me than the default bindings of
=C-c C-n= and =C-c C-u=.

#+begin_src emacs-lisp
  (use-package company-coq
    :hook (coq-mode . company-coq-mode)

    :config
    (evil-define-key 'normal coq-mode-map (kbd "<down>") 'proof-assert-next-command-interactive)
    (evil-define-key 'insert coq-mode-map (kbd "<down>") 'proof-assert-next-command-interactive)

    (evil-define-key 'normal coq-mode-map (kbd "<up>") 'proof-undo-last-successful-command)
    (evil-define-key 'insert coq-mode-map (kbd "<up>") 'proof-undo-last-successful-command))
#+end_src

** =cron=

Add syntax highlighting to =cron= files.

#+begin_src emacs-lisp
  (use-package crontab-mode)
#+end_src

** CSS & Sass

Indent by 2 spaces.

#+begin_src emacs-lisp
  (use-package css-mode
    :config
    (setq css-indent-offset 2))
#+end_src

Don't compile the current SCSS file every time I save.

#+begin_src emacs-lisp
  (use-package scss-mode
    :config
    (setq scss-compile-at-save nil))
#+end_src

** Go

Install =go-mode=, plus =protobuf-mode=.

#+begin_src emacs-lisp
  (use-package go-mode
    :ensure-system-package ((go . golang)
                            (gopls . "go install golang.org/x/tools/gopls@latest"))
    :bind (:map go-mode-map ("C-c C-c" . compile)))

  (use-package protobuf-mode)
#+end_src

Define my =$GOPATH= and tell Emacs where to find the Go binaries.

#+begin_src emacs-lisp
  (setenv "GOPATH" (expand-file-name "~/code/go"))
  (+append-to-path (concat (getenv "GOPATH") "/bin"))
#+end_src

When I save a Go file, reformat the buffer (per =gofmt=) and organize the imports
(per =goimports=).

#+begin_src emacs-lisp
  (defun +install-go-save-hooks ()
    (add-hook 'before-save-hook #'lsp-format-buffer t t)
    (add-hook 'before-save-hook #'lsp-organize-imports t t))

  (add-hook 'go-mode-hook #'+install-go-save-hooks)
#+end_src

Redefine the default =compile= command to build the whole project, run tests, and
run =go vet= without requiring any additional confirmation. That's bound to =C-c
C-c= in the =use-package= configuration above.

#+begin_src emacs-lisp
  (defun +set-go-compilation-configuration ()
    (set (make-local-variable 'compilation-read-command) nil)
    (set (make-local-variable 'compile-command)
         "go build -v ./... && go test -race ./... && go vet ./...")
    (set (make-local-variable 'default-directory) (project-root (project-current))))

  (add-hook 'go-mode-hook #'+set-go-compilation-configuration)
#+end_src

** Haskell

Enable =haskell-doc-mode=, which displays the type signature of a function, and
use smart indentation.

#+begin_src emacs-lisp
  (use-package haskell-mode
    :hook (haskell-mode . (lambda ()
                            (haskell-doc-mode)
                            (turn-on-haskell-indent))))
#+end_src

** JavaScript

Indent everything by 2 spaces.

#+begin_src emacs-lisp
  (setq js-indent-level 2)
#+end_src

Browse JSON documents hierarchically with =json-navigator-navigate-after-point=.

#+begin_src emacs-lisp
  (use-package json-navigator
    :commands (json-navigator-navigate-after-point))
#+end_src

** Lisps

=rainbow-delimiters= is convenient for coloring matching parentheses.

#+begin_src emacs-lisp
  (use-package rainbow-delimiters
    :hook ((emacs-lisp-mode lisp-mode racket-mode) . rainbow-delimiters-mode))
#+end_src

*** Common Lisp

Set up [[https://slime.common-lisp.dev/][SLIME]] to interactively hack on Common Lisp.

#+begin_src emacs-lisp
  (use-package slime
    :ensure-system-package sbcl
    :commands (slime)

    :config
    (setq inferior-lisp-program "sbcl")
    (load (expand-file-name "~/.quicklisp/slime-helper.el"))
    (add-to-list 'slime-contribs 'slime-autodoc))
#+end_src

*** Emacs Lisp

If I'm writing in Emacs Lisp I'd like to use =eldoc-mode= to display
documentation.

#+begin_src emacs-lisp
  (use-package eldoc
    :hook (emacs-lisp-mode . eldoc-mode))
#+end_src

*** Racket

#+begin_src emacs-lisp
  (use-package racket-mode
    :ensure-system-package racket
    :hook (racket-mode . racket-xp-mode)
    :mode "\\.rkt\\'")

  (use-package geiser
    :after racket-mode
    :config
    (setq geiser-active-implementations '(racket)))
#+end_src

Quit documentation buffers.

 #+begin_src emacs-lisp
  (evil-define-key 'normal racket-describe-mode (kbd "q") 'quit-window)
#+end_src

** OCaml

Use =tuareg-mode= for editing OCaml.

#+begin_src emacs-lisp
  (use-package tuareg
    :ensure-system-package opam

    :config
    (electric-indent-mode 0))
#+end_src

Configure Merlin. This also requires installing the Merlin package through OPAM
with =opam install merlin=.

#+begin_src emacs-lisp
  (use-package merlin
    :after tuareg-mode
    :hook (tuareg-mode . merlin-mode))
#+end_src

** Python

#+begin_src emacs-lisp
  (use-package python-mode)
#+end_src

Enable =elpy=. This provides automatic indentation, auto-completion, syntax
checking, etc. Use the =python3= interpreter for eldoc.

#+begin_src emacs-lisp
  (use-package elpy
    :after python-mode

    :custom
    (elpy-rpc-python-command "python3")

    :config
    (elpy-enable))
#+end_src

Format code according to PEP8 on save:

#+begin_src emacs-lisp
  (use-package py-autopep8
    :after python-mode
    :hook (elpy-mode-hook . py-autopep8-enable-on-save))
#+end_src

** Ruby

This defines a default Ruby version to use within Emacs (for things like =xmp= or
=rspec=).

#+begin_src emacs-lisp
  (setq +ruby-version "3.1.2")
#+end_src

Ruby executables are installed in =~/.gem/ruby/<version>/bin=. This ensures that
that's included in the path. In particular, we want that directory to be
included because it contains the =xmpfilter= executable.

#+begin_src emacs-lisp
  (+append-to-path (format "~/.gem/ruby/%s/bin" +ruby-version))
#+end_src

I associate =ruby-mode= with Gemfiles, gemspecs, Rakefiles, and Vagrantfiles.

There are a bunch of things I'd like to do when I open a Ruby buffer:

- =C-c C-c= should run =xmp=, to do that nifty "eval into comments" trick.
- Hitting "enter" should indent to the current level.
- Disable =reek=, which I don't find helpful.
- When assigning the result of a conditional, I like to align the expression to
  match the beginning of the statement instead of indenting it all the way to
  the =if=.

#+begin_src emacs-lisp
  (use-package ruby-mode
    :ensure-system-package (xmpfilter . "gem install rcodetools")

    :mode ("\\.rake$"
           "\\.gemspec$"
           "\\Guardfile$"
           "\\Rakefile$"
           "\\Vagrantfile$"
           "\\Vagrantfile.local$")

    :bind (("C-c C-c" . xmp)
           ("\r" . newline-and-indent))

    :config
    (setq-default flycheck-disabled-checkers '(ruby-reek))
    (setq ruby-align-to-stmt-keywords '(def if)))
#+end_src

I use =chruby= to switch between versions of Ruby.

#+begin_src emacs-lisp
  (use-package chruby
    :after ruby-mode
    :hook (ruby . chruby-use-corresponding)
    :config
    (chruby +ruby-version))
#+end_src

Running tests from within Emacs is awfully convenient. I enable =rspec-mode=
basically everywhere, since working with a Rails project involves a ton of
modes.

I'd like my =rspec= tests to be run in a random order, and I'd like the output
to be colored.

#+begin_src emacs-lisp
  (use-package rspec-mode
    :after ruby-mode
    :ensure-system-package (rspec . "gem install rspec")

    :hook (css-mode
           deadgrep-mode
           eldoc-mode
           js-mode
           magit-status-mode
           ruby-mode
           scss-mode
           web-mode
           yard-mode)

    :custom
    (compilation-scroll-output nil)
    (rspec-command-options "--color --order random")
    (rspec-use-chruby t)

    :config
    (evil-define-key 'motion rspec-mode-map (kbd "C-p") 'project-find-file)
    (evil-define-key 'motion rspec-compilation-mode-map (kbd "C-p") 'project-find-file)

    (add-hook 'compilation-filter-hook 'inf-ruby-auto-enter))
#+end_src

Some Ruby projects use =minitest= instead of =rspec=.

#+begin_src emacs-lisp
  (use-package minitest
    :after ruby-mode
    :custom
    (compilation-scroll-output nil))
#+end_src

=rspec-mode= and =minitest-mode= use the same keybindings for running tests.
That's great for muscle memory, but it means that it's better to only have one
or the other active at any given time. This checks the root of the current
project for a =tests= directory. If it finds one it activates =minitest-mode=,
and if it doesn't (or if we're not in a project) it uses =rspec-mode=. Kinda
hacky, but seems to do the job.

#+begin_src emacs-lisp
  (defvar +ruby-testable-mode-hooks
    '(css-mode-hook
      deadgrep-mode-hook
      eldoc-mode-hook
      js-mode-hook
      magit-status-mode-hook
      ruby-mode-hook
      scss-mode-hook
      web-mode-hook
      yard-mode-hook))

  (defun +current-project-uses-minitest-p ()
    (and (project-current)
         (file-directory-p (expand-file-name "test" (project-root (project-current))))))

  (defun +activate-ruby-tests-mode ()
    (if (+current-project-uses-minitest-p)
        (progn
          (minitest-mode 1)
          (rspec-mode 0)
          (rspec-verifiable-mode 0))
        (progn
          (minitest-mode 0)
          (rspec-mode 1)
          (rspec-verifiable-mode 1))))

  (dolist (hook +ruby-testable-mode-hooks)
    (add-hook hook #'+activate-ruby-tests-mode))
#+end_src

=rcodetools= provides =xmp=, which lets me evaluate a Ruby buffer and display the
results in "magic" (=# ==>=) comments.

I disable warnings when running code through =xmp= because I disagree with a few
of them (complaining about private =attr_reader=, especially) and they gunk up my
buffer.

#+begin_src emacs-lisp
  (use-package rcodetools
    :after ruby-mode
    :load-path "resources"
    :commands (xmp)

    :config
    (setq xmpfilter-command-name
          "ruby -S xmpfilter --no-warnings --dev --fork --detect-rbtest"))
#+end_src

Ruby method comments are often formatted with Yard.

#+begin_src emacs-lisp
  (use-package yard-mode
    :after ruby-mode
    :hook ruby-mode)
#+end_src

Insert =end= keywords automatically when I start to define a method, class,
module, or block.

#+begin_src emacs-lisp
  (use-package ruby-end
    :after ruby-mode)
#+end_src

** Rust

Use =rustic= to edit Rust code.

#+begin_src emacs-lisp
  (use-package rustic
    :bind (:map rustic-mode-map
                ("M-j" . lsp-ui-imenu)
                ("M-?" . lsp-find-references)
                ("C-c C-c l" . flycheck-list-errors)
                ("C-c C-c a" . lsp-execute-code-action)
                ("C-c C-c r" . lsp-rename)
                ("C-c C-c q" . lsp-workspace-restart)
                ("C-c C-c Q" . lsp-workspace-shutdown)
                ("C-c C-c s" . lsp-rust-analyzer-status))

    :config
    (setq lsp-rust-analyzer-cargo-watch-command "clippy")
    (setq lsp-rust-analyzer-server-display-inlay-hints t)

    (setq rustic-format-on-save t)
    (add-hook 'rustic-mode-hook '+rustic-mode-hook))

  (defun +rustic-mode-hook ()
    "Don't prompt for confirmation before running `rustfmt'."
    (setq-local buffer-save-without-query t))
#+end_src

** =sh=

Indent with 2 spaces.

#+begin_src emacs-lisp
  (add-hook 'sh-mode-hook
            (lambda ()
              (setq sh-basic-offset 2
                    sh-indentation 2)))
#+end_src

** Scala

Ensure that =scala-mode= and =sbt-mode= are installed.

#+begin_src emacs-lisp
  (use-package scala-mode
    :interpreter ("scala" . scala-mode))

  (use-package sbt-mode
    :after scala-mode
    :commands sbt-start sbt-command

    :config
    (substitute-key-definition 'minibuffer-complete-word
                               'self-insert-command
                               minibuffer-local-completion-map))

  (use-package hydra)
#+end_src

Don't show the startup message with launching ENSIME:

#+begin_src emacs-lisp
  (setq ensime-startup-notification nil)
#+end_src

Bind a few keys to common operations:

#+begin_src emacs-lisp
  (evil-define-key 'normal ensime-mode-map (kbd "C-t") 'ensime-type-at-point)
  (evil-define-key 'normal ensime-mode-map (kbd "M-.") 'ensime-edit-definition)
#+end_src

** SQL

Support syntax-based indentation when editing SQL files.

#+begin_src emacs-lisp
  (use-package sql-indent
    :hook (sql-mode . sqlind-minor-mode))
#+end_src

** Terraform

Install =terraform-mode=.

#+begin_src emacs-lisp
  (use-package terraform-mode
    :ensure-system-package terraform
    :custom
    (terraform-format-on-save t))

  (use-package company-terraform
    :after terraform-mode
    :config
    (company-terraform-init))
#+end_src

** =web-mode=

Use =web-mode= with embedded Ruby files, regular HTML, and PHP.

#+begin_src emacs-lisp
  (use-package web-mode
    :mode ("\\.erb$"
           "\\.html$"
           "\\.php$"
           "\\.rhtml$")

    :config
    (setq web-mode-markup-indent-offset 2
          web-mode-css-indent-offset 2
          web-mode-code-indent-offset 2
          web-mode-indent-style 2))
#+end_src

I'd like to see colors with =rainbow-mode=, so we'll need to install that, too:

#+begin_src emacs-lisp
  (use-package rainbow-mode
    :hook web-mode)
#+end_src

** YAML

This is not a place of honor.

#+begin_src emacs-lisp
  (use-package yaml-mode)
#+end_src

* Terminal

I'm trying =vterm=. This disables =global-hl-line-mode= locally and lets me open up
a new terminal instance with =C-c t=.

#+begin_src emacs-lisp
  (use-package multi-vterm
    :ensure-system-package (cmake
                            ("/usr/share/doc/libvterm-dev" . libvterm-dev))
    :commands (multi-vterm)
    :hook (vterm-mode-hook . (lambda () (setq-local global-hl-line-mode nil))))

  (global-set-key (kbd "C-c t") 'multi-vterm)
#+end_src

* Password management

I manage my passwords with [[https://www.passwordstore.org/][=pass=]], a nifty command-line utility that's
accessible through Emacs.

I'll also occasionally use =pwgen= to generate and insert a secure password.

#+begin_src emacs-lisp
  (use-package password-store
    :ensure-system-package pass)

  (use-package password-store-otp)

  (defun +insert-password ()
    (interactive)
    (shell-command "pwgen 30 --num-passwords=1 --secure | tr --delete '\n'" t))
#+end_src

* Publishing and task management with Org-mode

Including =org-tempo= restores the =<s=-style easy templates that were deprecated in
Org 9.2.

I'd like to open =file:= links in Org with the applications defined in my [[file:~/.dotfiles/email/.mailcap][mailcap]].
This clears the existing MIME mapping, parses my personal mailcap, and tells Org
to open those links with the mailcap-defined applications.

#+begin_src emacs-lisp
  (use-package org
    :config
    (require 'org-tempo)

    (add-hook 'org-mode-hook
              (lambda ()
                (setq mailcap-mime-data '())
                (mailcap-parse-mailcap "~/.mailcap")
                (setq org-file-apps
                      '((auto-mode . emacs)
                        ("mobi" . "foliate %s")
                        ("\\.x?html?\\'" . mailcap)
                        ("pdf" . mailcap)
                        (system . mailcap)
                        (t . mailcap))))))
#+end_src

I'd like the initial scratch buffer to be in Org:

#+begin_src emacs-lisp
  (setq initial-major-mode 'org-mode)
#+end_src

** Display preferences

Put tags directly after the associated header rather than trying to align them.

#+begin_src emacs-lisp
  (setq org-auto-align-tags nil
        org-tags-column 0)
#+end_src

When editing a code snippet, use the current window rather than popping open a
new one (which shows the same information).

#+begin_src emacs-lisp
  (setq org-src-window-setup 'current-window)
#+end_src

Quickly insert a block of elisp:

#+begin_src emacs-lisp
  (add-to-list 'org-structure-template-alist
               '("el" . "src emacs-lisp"))
#+end_src

When hitting =C-<return>= to create a new heading, don't insert the heading
between the current heading and its content, but instead append it /after/ the
content.

#+begin_src emacs-lisp
  (setq org-insert-heading-respect-content t)
#+end_src

** Task management and agenda views

Store my org files in =~/documents/org= and define the location of an index file
(my main todo list).

#+begin_src emacs-lisp
  (setq org-directory "~/documents/org")

  (defun org-file-path (filename)
    "Return the absolute address of an org file, given its relative name."
    (concat (file-name-as-directory org-directory) filename))

  (setq org-index-file (org-file-path "index.org"))

  (setq org-refile-targets `((,org-index-file :level . 1)
                             (,(org-file-path "deliveries.org") :level . 1)
                             (,(org-file-path "someday-maybe.org") :level . 1)))
#+end_src

Archive finished tasks in =~/documents/org/archive/archive-YYYY-MM-DD.org=. Since
I often leave Emacs running overnight, I reset the update location at midnight.

#+begin_src emacs-lisp
  (defun +set-org-archive-location ()
    "Set the `org-archive-location' variable according to the current date."
    (setq org-archive-location
          (concat
           (org-file-path (format-time-string "archive/archive-%Y-%m-%d.org"))
           "::* From %s")))

  (+set-org-archive-location)

  (use-package midnight
    :demand t
    :custom
    (midnight-delay 0)
    :config
    (midnight-mode 1)
    (add-hook 'midnight-hook #'+set-org-archive-location))
#+end_src

I store most of my personal tasks in my index and maintain a separate file for
work-related tasks, so I'd like to derive my agenda from those files.

I also keep a schedule in =events.org=. Plus some recurring events in,
reasonably, a =recurring-events.org= file. Those are (mostly) structured as
=org-habit= items so they can recur according to a schedule.

#+begin_src emacs-lisp
  (setq org-agenda-files
        (mapcar 'org-file-path '("calendars"
                                 "deliveries.org"
                                 "habits.org"
                                 "index.org"
                                 "news.org"
                                 "recurring-events.org"
                                 "recurring-tasks.org"
                                 "writing.org")))
#+end_src

Record the time that a todo was archived.

#+begin_src emacs-lisp
  (setq org-log-done 'time)
#+end_src

Ensure that a task can't be marked as done if it contains unfinished subtasks.
This is handy for organizing "blocking" tasks hierarchically.

#+begin_src emacs-lisp
  (setq org-enforce-todo-dependencies t)
#+end_src

Open my agenda in the current window instead of creating a new one.

#+begin_src emacs-lisp
  (setq org-agenda-window-setup 'current-window)
#+end_src

Begin weeks /today/, not on the last Monday.

#+begin_src emacs-lisp
  (setq org-agenda-start-on-weekday nil)
#+end_src

Don't show deadline warnings under today's entry. If something's due in two
days, I'll see it in my agenda as a deadline on that day; I don't /also/ need it
listed under today's tasks, prefixed with =In 2 d:=.

#+begin_src emacs-lisp
  (setq org-deadline-warning-days 0)
#+end_src

Separate org blocks with nearly complete lines, not rows of ===.

#+begin_src emacs-lisp
  (setq org-agenda-block-separator ?─
        org-agenda-time-grid
        '((daily today require-timed)
          (800 1000 1200 1400 1600 1800 2000)
          " ┄┄┄┄┄ " "┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄")
        org-agenda-current-time-string
        "⭠ now ─────────────────────────────────────────────────")
#+end_src

Hide the category prefix from tasks. I categorize my tasks with tags, including
using =filetags=, so prefixing tasks with the file they're stored in is noisy and
redundant.

#+begin_src emacs-lisp
  (setq org-agenda-prefix-format '((agenda . " %i %?-12t% s")
                                   (todo . " %i ")
                                   (tags . " %i ")
                                   (search . " %i ")))
#+end_src

By default Org will dim any tasks that contain blocking subtasks. That's good,
but I've got enough of those that I'd rather not see them at all.

By making blocked tasks invisible I ensure that everything in my agenda is
currently actionable. Or, in GTD lingo, I'm only seeing "next steps."

#+begin_src emacs-lisp
  (setq org-agenda-dim-blocked-tasks 'invisible)
#+end_src

Hide blocks in the agenda that don't contain any tasks. From [[https://lists.gnu.org/archive/html/emacs-orgmode/2015-06/msg00266.html][this email thread]].

#+begin_src emacs-lisp
  (defun org-agenda-delete-empty-blocks ()
    "Remove empty agenda blocks.
  A block is identified as empty if there are fewer than 2
  non-empty lines in the block (excluding the line with
  `org-agenda-block-separator' characters)."
    (when org-agenda-compact-blocks
      (user-error "Cannot delete empty compact blocks"))
    (setq buffer-read-only nil)
    (save-excursion
      (goto-char (point-min))
      (let* ((blank-line-re "^\\s-*$")
             (content-line-count (if (looking-at-p blank-line-re) 0 1))
             (start-pos (point))
             (block-re (format "%c\\{10,\\}" org-agenda-block-separator)))
        (while (and (not (eobp)) (forward-line))
          (cond
           ((looking-at-p block-re)
            (when (< content-line-count 2)
              (delete-region start-pos (1+ (point-at-bol))))
            (setq start-pos (point))
            (forward-line)
            (setq content-line-count (if (looking-at-p blank-line-re) 0 1)))
           ((not (looking-at-p blank-line-re))
            (setq content-line-count (1+ content-line-count)))))
        (when (< content-line-count 2)
          (delete-region start-pos (point-max)))
        (goto-char (point-min))
        ;; The above strategy can leave a separator line at the beginning
        ;; of the buffer.
        (when (looking-at-p block-re)
          (delete-region (point) (1+ (point-at-eol))))))
    (setq buffer-read-only t))

  (add-hook 'org-agenda-finalize-hook #'org-agenda-delete-empty-blocks)
#+end_src

The "Personal agenda" view is simpler than it seems. I'm mostly sorting tasks by
the =inbox=, =habit=, and =project= tags. Here are the sections:

- Inbox :: Newly captured notes or ideas that haven't yet been turned into
  "real" tasks or projects, /or/ tasks that have been deferred until today and
  require reexamination.
- Next :: Next unblocked steps in projects (or stand-alone tasks).
- Habit :: Automatically generated tasks appended to a file with a custom
  script. This includes stuff like, y'know, exercising, feeding the sourdough
  starter, or resetting my watch for daylight savings time. I could probably
  replace this script with [[https://orgmode.org/manual/Tracking-your-habits.html][org-habit]], but I don't for mostly historical reasons.
- Calendar :: I have a =cron= job that pulls down my calendars into an Org file,
  so my day's meetings, pending deliveries, and so on are displayed in my
  agenda. This also shows tasks with deadlines and so on that I might not have
  tagged.
- Projects :: The list of GTD-style projects that I'm currently working on.

#+begin_src emacs-lisp
  (setq org-agenda-custom-commands '())

  (add-to-list 'org-agenda-custom-commands
               '("p" "Personal agenda"
                 ((tags-todo "inbox|tickler+SCHEDULED=\"<today>\"|tickler+DEADLINE=\"<today>\""
                             ((org-agenda-overriding-header "Inbox")))

                  (tags-todo "next"
                             ((org-agenda-overriding-header "Next")))

                  (tags-todo "habit-daily"
                             ((org-agenda-overriding-header "Habits")))

                  (agenda ""
                          ((org-agenda-overriding-header "Calendar")
                           (org-agenda-tag-filter-preset '("-next" "-habit"))))

                  (tags-todo "project"
                             ((org-agenda-overriding-header "Projects"))))

                 ((org-agenda-skip-deadline-if-done t)
                  (org-agenda-skip-scheduled-if-done t)
                  (org-agenda-skip-timestamp-if-done t)
                  (org-agenda-hide-tags-regexp "calendar\\|habit\\|inbox\\|next\\|project")
                  (org-agenda-tag-filter-preset '("-duplicate" "-news" "-writing")))))
#+end_src

Org treats unprioritized entries as if they had a priority of =[#B]=. I'd prefer
to treat them as the lowest priority, which I'm leaving as =[#C]=. That ensures
that prioritized entries always come before unprioritized ones in my agenda.

#+begin_src emacs-lisp
(setq org-default-priority ?C)
#+end_src

I consult my agenda pretty often, so I bind =C-c d= to open it a bit faster.

#+begin_src emacs-lisp
  (defun +dashboard ()
    (interactive)
    (call-process-shell-command "daily-checklist")
    (find-file org-index-file)
    (with-current-buffer (get-file-buffer org-index-file)
      (revert-buffer nil t))
    (delete-other-windows)
    (org-agenda nil "p"))

  (global-set-key (kbd "C-c d") '+dashboard)
#+end_src

Shorten the default (lengthy) =org-agenda= modeline.

#+begin_src emacs-lisp
  (defadvice org-agenda-set-mode-name (after truncate-org-agenda-mode-name activate)
    (setq mode-name '("Org-agenda")))
#+end_src

I have a number of standing weekly video calls with friends and family, and I
like keeping track of what happened in the last week to share on those calls.
Because my memories only exist in text files, I have a custom view to list news
items from the last couple weeks.

#+begin_src emacs-lisp
  (add-to-list 'org-agenda-custom-commands
               '("n" "News from this week"
                 ((agenda ""))
                 ((org-agenda-overriding-header "News from this week")
                  (org-agenda-start-day "-14d")
                  (org-agenda-span 21)
                  (org-agenda-files '("~/documents/org/news.org"
                                      "~/documents/org/recurring-events.org"
                                      "~/documents/notes/bird-log.org"
                                      "~/documents/notes/books-read.org"
                                      "~/documents/notes/papers-read.org")))))
#+end_src

I do a ton of journaling! I maintain a list of topics I'd like to think through
and pop it open when I'm ready to write.

#+begin_src emacs-lisp
  (add-to-list 'org-agenda-custom-commands
               '("w" "Writing prompts"
                 ((tags "+writing"))
                 ((org-agenda-overriding-header "Writing prompts")
                  (org-agenda-sorting-strategy '((agenda ts-down))))))
#+end_src

*** Capturing tasks

Define a few common tasks as capture templates.

#+begin_src emacs-lisp
  (defvar org-capture-templates '())

  (add-to-list 'org-capture-templates
               '("b" "Blog idea"
                 entry
                 (file "~/documents/notes/blog-ideas.org")
                 "* %?\n"))

  (add-to-list 'org-capture-templates
               '("c" "Contact"
                 entry
                 (file "~/documents/contacts.org")
                 "* %(org-contacts-template-name)
:PROPERTIES:
:ADDRESS: %^{123 Fake St., City, ST 12345}
:PHONE: %^{555-555-5555}
:EMAIL: %(org-contacts-template-email)
:NOTE: %^{note}
:END:"))

  (add-to-list 'org-capture-templates
               '("d" "Delivery"
                 entry
                 (file+headline "~/documents/org/deliveries.org" "Deliveries")
                 "** %?\nSCHEDULED: %^t\n"))

  (add-to-list 'org-capture-templates
               '("e" "Email"
                 entry
                 (file+headline org-index-file "Inbox")
                 "* TODO %?\n%a\n"))

  (add-to-list 'org-capture-templates
               '("f" "Finished book"
                 entry
                 (file+headline "~/documents/notes/books-read.org" "Books")
                 "* %^{Title} -- %^{Author}\n%^t\n"
                 :immediate-finish t))

  (add-to-list 'org-capture-templates
               '("k" "Kookaburra ingest"
                 entry
                 (file+headline "~/documents/org/kookaburra-ingest.org" "Queue")
                 "* TODO %?\n"))

  (add-to-list 'org-capture-templates
               '("m" "Media queue"
                 item
                 (file+headline "~/documents/notes/media.org" "Inbox")
                 "- [ ] %^{Media}\n"
                 :immediate-finish t))

  (add-to-list 'org-capture-templates
               '("n" "News item"
                 entry
                 (file "~/documents/org/news.org")
                 "* %?\n%t\n"))

  (add-to-list 'org-capture-templates
               '("p" "Finished paper"
                 entry
                 (file+headline "~/documents/notes/papers-read.org" "Papers")
                 "* %^{Title} -- %^{Author}\n%t\n"
                 :immediate-finish t))

  (add-to-list 'org-capture-templates
               '("r" "Writing prompt"
                 entry
                 (file "~/documents/org/writing.org")
                 "* %?\n%t\n"))

  (add-to-list 'org-capture-templates
               '("s" "Subscribe to an RSS feed"
                 plain
                 (file "~/documents/rss-feeds.org")
                 "*** [[%^{Feed URL}][%^{Feed name}]]"
                 :immediate-finish t))

  (add-to-list 'org-capture-templates
               '("t" "Task"
                 entry
                 (file+headline org-index-file "Inbox")
                 "* TODO %?\n"))
#+end_src

When I'm starting an Org capture template I'd like to begin in insert mode. I'm
opening it up in order to start typing something, so this skips a step.

#+begin_src emacs-lisp
  (add-hook 'org-capture-mode-hook 'evil-insert-state)
#+end_src

Creating a new capture item also adds a bookmark, which includes a marker in the
fringe. I don't need to see that, so:

#+begin_src emacs-lisp
  (setq bookmark-set-fringe-mark nil)
#+end_src

Refiling according to the document's hierarchy.

#+begin_src emacs-lisp
  (use-package org-refile
    :ensure nil
    :custom
    (org-refile-use-outline-path t)
    (org-outline-path-complete-in-steps nil))
#+end_src

*** Keybindings

Bind a few handy keys.

#+begin_src emacs-lisp
  (define-key global-map "\C-cl" 'org-store-link)
  (define-key global-map "\C-ca" 'org-agenda)
  (define-key global-map "\C-cc" 'org-capture)
#+end_src

Hit =C-c i= to quickly open up my todo list.

#+begin_src emacs-lisp
  (defun +open-index-file ()
    "Open the master org TODO list."
    (interactive)
    (find-file org-index-file)
    (flycheck-mode -1)
    (end-of-buffer))

  (global-set-key (kbd "C-c i") '+open-index-file)
#+end_src

Hit =M-n= to quickly open up a capture template for a new todo.

#+begin_src emacs-lisp
  (defun +org-capture-todo ()
    (interactive)
    (org-capture :keys "t"))

  (global-set-key (kbd "M-n") '+org-capture-todo)

  (setq +org-capture-todo-hooks '(gfm-mode-hook haskell-mode-hook magit-mode-hook))

  (dolist (hook +org-capture-todo-hooks)
    (add-hook hook (lambda () (local-set-key (kbd "M-n") '+org-capture-todo))))
#+end_src

Rebind =C-c C-l= to [[https://xenodium.com/emacs-dwim-do-what-i-mean/][DWIM]]:

#+begin_src emacs-lisp
  (defun +org-insert-link-dwim ()
    "Like `org-insert-link' but with personal dwim preferences."
    (interactive)
    (let* ((point-in-link (org-in-regexp org-link-any-re 1))
           (clipboard-url (when (string-match-p "^http" (current-kill 0))
                            (current-kill 0)))
           (region-content (when (region-active-p)
                             (buffer-substring-no-properties (region-beginning)
                                                             (region-end)))))
      (cond ((and region-content clipboard-url (not point-in-link))
             (delete-region (region-beginning) (region-end))
             (insert (org-make-link-string clipboard-url region-content))
             (message clipboard-url))
            ((and clipboard-url (not point-in-link))
             (insert (org-make-link-string
                      clipboard-url
                      (read-string "title: "
                                   (with-current-buffer (url-retrieve-synchronously clipboard-url)
                                     (dom-text (car
                                                (dom-by-tag (libxml-parse-html-region
                                                             (point-min)
                                                             (point-max))
                                                            'title))))))))
            (t
             (call-interactively 'org-insert-link)))))

  (define-key org-mode-map (kbd "C-c C-l") '+org-insert-link-dwim)
#+end_src

Add a function to link the selected text to its associated Wikipedia article.

#+begin_src emacs-lisp
  (defun +apply-to-region (fn)
    (interactive "XFunction to apply to region: ")
    (save-excursion
      (let* ((beg (region-beginning))
             (end (region-end))
             (resulting-text
              (funcall
               fn
               (buffer-substring-no-properties beg end))))
        (kill-region beg end)
        (insert resulting-text))))

  (defun +org-insert-wikipedia-link ()
    (interactive)
    (+apply-to-region (lambda (string)
                        "Convert a string to a link to English Wikipedia"
                        (concat "[[https://en.wikipedia.org/wiki/" (subst-char-in-string ?  ?_ string) "]"
                                "[" string "]]"))))
#+end_src

** Exporting

Allow export to markdown and epub.

#+begin_src emacs-lisp
  (use-package ox-md
    :ensure nil
    :after org
    :commands (org-export-dispatch))

  (use-package ox-epub
    :after org
    :commands (org-export-dispatch))
#+end_src

Allow =babel= to evaluate code blocks in a handful of languages.

#+begin_src emacs-lisp
  (use-package gnuplot
    :ensure-system-package gnuplot)

  (org-babel-do-load-languages
   'org-babel-load-languages
   '((ditaa . t)
     (dot . t)
     (emacs-lisp . t)
     (gnuplot . t)
     (ruby . t)
     (shell . t)))
#+end_src

Don't ask before evaluating code blocks.

#+begin_src emacs-lisp
  (setq org-confirm-babel-evaluate nil)
#+end_src

Use =htmlize= to ensure that exported code blocks use syntax highlighting.

#+begin_src emacs-lisp
  (use-package htmlize)
#+end_src

Associate the "dot" language with the =graphviz-dot= major mode.

#+begin_src emacs-lisp
  (use-package graphviz-dot-mode
    :ensure-system-package (dot . graphviz)

    :config
    (add-to-list 'org-src-lang-modes '("dot" . graphviz-dot)))
#+end_src

Translate regular ol' straight quotes to typographically correct curly quotes
when exporting.

#+begin_src emacs-lisp
  (setq org-export-with-smart-quotes t)
#+end_src

**** Exporting to HTML

Don't include a footer with my contact and publishing information at the bottom
of every exported HTML document.

#+begin_src emacs-lisp
  (setq org-html-postamble nil)
#+end_src

**** Exporting to PDF

- I want to produce PDFs with syntax highlighting in the code. The best way to
  do that seems to be with the =minted= package, but that package shells out to
  =pygments= to do the actual work. =xelatex= usually disallows shell commands;
  this enables that.
- Include the =minted= package in all of my LaTeX exports.
- Remove the intermediate TeX file when exporting to PDF.

#+begin_src emacs-lisp
  (use-package ox-latex
    :ensure nil
    :after org
    :commands (org-export-dispatch)

    :custom
    (org-latex-pdf-process
     '("xelatex -shell-escape -interaction nonstopmode -output-directory %o %f"
       "xelatex -shell-escape -interaction nonstopmode -output-directory %o %f"
       "xelatex -shell-escape -interaction nonstopmode -output-directory %o %f"))
    (org-latex-src-block-backend 'minted)

    :config
    (add-to-list 'org-latex-packages-alist '("" "minted"))
    (add-to-list 'org-latex-logfiles-extensions "tex"))
#+end_src

Allow exporting presentations to beamer.

#+begin_src emacs-lisp
  (use-package ox-beamer
    :ensure nil
    :after ox-latex)
#+end_src

** TeX configuration

I rarely write LaTeX directly any more, but I often export through it with
org-mode, so I'm keeping them together.

Automatically parse the file after loading it.

#+begin_src emacs-lisp
  (setq TeX-parse-self t)
#+end_src

Always use =pdflatex= when compiling LaTeX documents. I don't really have any
use for DVIs.

#+begin_src emacs-lisp
  (setq TeX-PDF-mode t)
#+end_src

Enable a minor mode for dealing with math (it adds a few useful keybindings),
and always treat the current file as the "main" file. That's intentional, since
I'm usually actually in an org document.

#+begin_src emacs-lisp
  (add-hook 'LaTeX-mode-hook
            (lambda ()
              (LaTeX-math-mode)
              (setq TeX-master t)))
#+end_src

Quickly run =make= in a LaTeX project by hitting =<f5>=.

#+begin_src emacs-lisp
  (add-hook 'LaTeX-mode-hook
            (lambda ()
              (define-key LaTeX-mode-map (kbd "<f5>")
                (lambda ()
                  (interactive)
                  (compile "make")))))
#+end_src

* Blogging

I maintain a blog written in Jekyll. There are plenty of command-line tools to
automate creating a new post, but staying in my editor minimizes friction and
encourages me to write.

This defines a =+new-blog-post= function, which prompts the user for a title and
creates a new draft (with a slugged file name) in the blog's =_drafts/= directory.
The new post includes appropriate YAML header information.

This also defines =+publish-post= and =+unpublish-post=, which adjust the date in
the YAML front matter and rename the file appropriately.

#+begin_src emacs-lisp
  (defvar +jekyll-drafts-directory (expand-file-name "~/documents/blog/_drafts/"))
  (defvar +jekyll-posts-directory (expand-file-name "~/documents/blog/_posts/"))
  (defvar +jekyll-post-extension ".md")

  (defun +timestamp ()
    (format-time-string "%Y-%m-%d"))

  (defun +replace-whitespace-with-hyphens (s)
    (replace-regexp-in-string " " "-" s))

  (defun +replace-nonalphanumeric-with-whitespace (s)
    (replace-regexp-in-string "[^A-Za-z0-9 ]" " " s))

  (defun +remove-quotes (s)
    (replace-regexp-in-string "[\'\"]" "" s))

  (defun +replace-unusual-characters (title)
    "Remove quotes, downcase everything, and replace characters
  that aren't alphanumeric with hyphens."
    (+replace-whitespace-with-hyphens
     (s-trim
      (downcase
       (+replace-nonalphanumeric-with-whitespace
        (+remove-quotes title))))))

  (defun +slug-for (title)
    "Given a blog post title, return a convenient URL slug.
     Downcase letters and remove special characters."
    (let ((slug (+replace-unusual-characters title)))
      (while (string-match "--" slug)
        (setq slug (replace-regexp-in-string "--" "-" slug)))
      slug))

  (defun +jekyll-yaml-template (title)
    "Return the YAML header information appropriate for a blog
     post. Include the title, the current date, the post layout,
     and an empty list of tags."
    (concat
     "---\n"
     "title: " title "\n"
     "date:\n"
     "layout: post\n"
     "# mathjax: true\n"
     "# pdf_file: " (+slug-for title) ".pdf\n"
     "tags: []\n"
     "---\n\n"))

  (defun +new-blog-post (title)
    "Create a new blog draft in Jekyll."
    (interactive "sPost title: ")
    (let ((post (concat +jekyll-drafts-directory
                        (+slug-for title)
                        +jekyll-post-extension)))
      (if (file-exists-p post)
          (find-file post)
        (find-file post)
        (insert (+jekyll-yaml-template title)))))

  (defun +jekyll-draft-p ()
    "Return true if the current buffer is a draft."
    (equal
     (file-name-directory (buffer-file-name (current-buffer)))
     +jekyll-drafts-directory))

  (defun +jekyll-published-p ()
    "Return true if the current buffer is a published post."
    (equal
     (file-name-directory (buffer-file-name (current-buffer)))
     +jekyll-posts-directory))

  (defun +publish-post ()
    "Move a draft post to the posts directory, rename it to include
  the date, reopen the new file, and insert the date in the YAML
  front matter."
    (interactive)
    (cond ((not (+jekyll-draft-p))
           (message "This is not a draft post."))
          ((buffer-modified-p)
           (message "Can't publish post; buffer has modifications."))
          (t
           (let ((filename
                  (concat +jekyll-posts-directory
                          (+timestamp) "-"
                          (file-name-nondirectory
                           (buffer-file-name (current-buffer)))))
                 (old-point (point)))
             (rename-file (buffer-file-name (current-buffer))
                          filename)
             (kill-buffer nil)
             (find-file filename)
             (set-window-point (selected-window) old-point)
             (save-excursion
               (beginning-of-buffer)
               (replace-regexp "^date:$" (concat "date: " (+timestamp))))
             (save-buffer)
             (message "Published post!")))))

  (defun +unpublish-post ()
    "Move a published post to the drafts directory, rename it to
  exclude the date, reopen the new file, and remove the date in the
  YAML front matter."
    (interactive)
    (cond ((not (+jekyll-published-p))
           (message "This is not a published post."))
          ((buffer-modified-p)
           (message "Can't publish post; buffer has modifications."))
          (t
           (let ((filename
                  (concat +jekyll-drafts-directory
                          (substring
                           (file-name-nondirectory
                            (buffer-file-name (current-buffer)))
                           11 nil)))
                 (old-point (point)))
             (rename-file (buffer-file-name (current-buffer))
                          filename)
             (kill-buffer nil)
             (find-file filename)
             (set-window-point (selected-window) old-point)
             (save-excursion
               (beginning-of-buffer)
               (replace-regexp "^date: [0-9][0-9][0-9][0-9]-[0-9][0-9]-[0-9][0-9]$" "date:"))
             (save-buffer)
             (message "Returned post to drafts!")))))
#+end_src

This selects and inserts a tag:

#+begin_src emacs-lisp
  (defun +tags-from-tag-line (line)
    "Given a line of tags from a blog post (like \"tags: [animals, design, cephalopods]\") return a sorted list of the tags (like '(\"animals\" \"cephalopods\" \"design\"))."
    (sort (mapcar #'string-trim
                  (-> (string-trim line)
                      (substring 7 -1)
                      (split-string ",")))
          #'string<))

  (defun +tag-lines ()
    "Return all the lines of tags from all existing blog posts."
    (seq-remove #'string-empty-p
                (split-string
                 (shell-command-to-string
                  (format "grep --no-filename \"^tags: \\[.*\\]$\" %s"
                          (concat (file-name-as-directory +jekyll-posts-directory) "*")))
                 "\n")))

  (defun +existing-blog-tags ()
    "Return a sorted list of all the tags used in my blog posts."
    (-> (mapcar #'+tags-from-tag-line (+tag-lines))
        (flatten-list)
        (seq-uniq)
        (sort #'string<)))

  (defun +insert-blog-tag ()
    "Prompt for one of the existing tags used in the blog and insert
  it in the YAML front matter appropriately."
    (interactive)
    (save-excursion
      (beginning-of-buffer)
      (search-forward-regexp "^tags: \\[")
      (insert
       (completing-read "Insert tag: " (+existing-blog-tags))
       (if (looking-at "\\]") "" ", ")))
    (message "Tagged!"))
#+end_src

* Email with =mu4e=

Inconveniently, =mu4e= is ordinarily distributed along with =mu= in my system's
package manager instead of as a package on MELPA. That package also seems to
have some trouble inter-operating with my (more recent and locally built)
version of Emacs. As a last resort, this loads up =mu4e= from a local repo.

Also, rather than quitting =mu4e=, just bury the buffer when I hit =q=.

#+begin_src emacs-lisp
  (use-package mu4e
    :commands mu4e
    :defer 2
    :load-path "~/media/code/mu/build/mu4e"

    :custom
    (mu4e-trash-folder "/personal/archive")
    (mu4e-refile-folder "/personal/archive")
    (mu4e-sent-folder "/personal/sent")
    (mu4e-drafts-folder "/personal/drafts")

    (mu4e-index-update-error-warning nil)
    (mu4e-hide-index-messages t)

    :config
    (evil-define-key 'normal mu4e-main-mode-map (kbd "q") 'bury-buffer)
    (mu4e t))
#+end_src

I use multiple contexts for personal and work email.

#+begin_src emacs-lisp
  (use-package mu4e-context
    :after mu4e
    :load-path "~/media/code/mu/build/mu4e"

    :config
    (defun +context-matches-p (msg context-name context-email)
      (if msg
          (mu4e-message-contact-field-matches msg '(:bcc :cc :to) context-email)
        (when (mu4e-context-current)
          (string= context-name (mu4e-context-name (mu4e-context-current))))))

    (setq mu4e-contexts
          `(,(make-mu4e-context
              :name "consulting"
              :match-func (lambda (msg) (+context-matches-p msg "consulting" "consulting@harryrschwartz.com"))
              :vars '((user-mail-address . "consulting@harryrschwartz.com")
                      (user-full-name . "Harry R. Schwartz")
                      (mu4e-trash-folder . "/personal/archive")
                      (mu4e-refile-folder . "/personal/archive")
                      (mu4e-sent-folder . "/personal/sent")
                      (mu4e-drafts-folder . "/personal/drafts")))

            ,(make-mu4e-context
              :name "test-double"
              :match-func (lambda (msg) (+context-matches-p msg "test-double" "harry.schwartz@testdouble.com"))
              :vars '((user-mail-address . "harry.schwartz@testdouble.com")
                      (user-full-name . "Harry R. Schwartz")
                      (mu4e-trash-folder . "/testdouble/archive")
                      (mu4e-refile-folder . "/testdouble/archive")
                      (mu4e-sent-folder . "/testdouble/sent")
                      (mu4e-drafts-folder . "/testdouble/drafts")))

            ,(make-mu4e-context
              :name "hrs"
              :match-func (lambda (msg) t)
              :vars '((user-mail-address . "hello@harryrschwartz.com")
                      (user-full-name . "Harry R. Schwartz")
                      (mu4e-trash-folder . "/personal/archive")
                      (mu4e-refile-folder . "/personal/archive")
                      (mu4e-sent-folder . "/personal/sent")
                      (mu4e-drafts-folder . "/personal/drafts"))))))
#+end_src

** Fetching new mail

- I fetch my email with =mbsync= every two minutes.
- Rename files when moving them between directories. =mbsync= supposedly prefers
  this.

#+begin_src emacs-lisp
  (use-package mu4e-bookmarks
    :after mu4e
    :load-path "~/media/code/mu/build/mu4e"

    :custom
    (mu4e-get-mail-command "mbsync --all")
    (mu4e-update-interval 120)
    (mu4e-change-filenames-when-moving t))
#+end_src

I don't want to be interrupted with a new mail alert, but I'd also like to know
when I've got some. This adds an unobtrusive notification to my modeline and
updates it every minute.

#+begin_src emacs-lisp
  (use-package mu4e-alert
    :demand t
    :after mu4e

    :config
    (setq mu4e-alert-interesting-mail-query "flag:unread (maildir:/personal/inbox OR maildir:/testdouble/inbox)")
    (mu4e-alert-enable-mode-line-display)
    (run-with-timer 0 60 'mu4e-alert-enable-mode-line-display))
#+end_src

** Listing mail

Hit =C-c m= to quickly visit my inbox.

#+begin_src emacs-lisp
  (defun +visit-inbox ()
    (interactive)
    (mu4e t)
    (delete-other-windows)
    (mu4e-search "maildir:/personal/inbox OR maildir:/testdouble/inbox"))

  (global-set-key (kbd "C-c m") '+visit-inbox)
#+end_src

Configure the main pane with some reasonable bookmarks. Don't show my (many)
email addresses, though, since they're just noise.

#+begin_src emacs-lisp
  (use-package mu4e-bookmarks
    :after mu4e
    :load-path "~/media/code/mu/build/mu4e"

    :custom
    (mu4e-main-hide-personal-addresses t)
    (mu4e-bookmarks
          '((:name "personal - inbox" :query "maildir:/personal/inbox" :key ?i)
            (:name "personal - drafts" :query "maildir:/personal/drafts" :key ?d)
            (:name "personal - sent" :query "maildir:/personal/sent" :key ?s)
            (:name "personal - archive" :query "maildir:/personal/archive" :key ?a)
            (:name "work - inbox" :query "maildir:/testdouble/inbox" :key ?w)
            (:name "today's messages" :query "date:today..now" :key ?t)
            (:name "last 7 days" :query "date:7d..now" :key ?7)))
    (mu4e-maildir-shortcuts
          '(("/personal/inbox" . ?i)
            ("/personal/drafts" . ?d)
            ("/personal/sent" . ?s)
            ("/personal/archive" . ?a))))
#+end_src

** Composing mail

- When I'm composing a new email, default to using the current context.
- Compose new messages (as with =C-x m=) using =mu4e-user-agent=.
- Once I've sent an email, kill the associated buffer instead of just burying
  it.
- If a message is encrypted, my reply should always be encrypted, too.

#+begin_src emacs-lisp
  (use-package mu4e-compose
    :after mu4e
    :load-path "~/media/code/mu/build/mu4e"
    :hook (mu4e-compose-mode . +encrypt-responses)

    :custom
    (mu4e-compose-context-policy nil)
    (mail-user-agent 'mu4e-user-agent)
    (message-kill-buffer-on-exit t)

    :config
    (defun +encrypt-responses ()
      "Encrypt the current message if it's a reply to another encrypted message."
      (let ((msg mu4e-compose-parent-message))
        (when (and msg (member 'encrypted (mu4e-message-field msg :flags)))
          (mml-secure-message-encrypt-pgpmime)))))
#+end_src

Write HTML emails in Org by toggling =org-msg-mode=.

I don't enable this by default because I usually prefer plain-text email, but
every now and then it's nice to be able to send a message with syntax
highlighting and LaTeX snippets (as PNGs) and all that fancy nonsense.

#+begin_src emacs-lisp
  (use-package org-msg
    :after (mu4e org)
    :config
    (setq org-msg-options "html-postamble:nil H:5 num:nil ^:{} toc:nil author:nil email:nil tex:dvipng \\n:t"
          org-msg-startup "inlineimages"
          org-msg-greeting-fmt "\nHello, %s,\n\n"
          org-msg-greeting-name-limit 3
          org-msg-text-plain-alternative t
          org-msg-signature "

  Cheers,
  #+begin_signature
  Harry Schwartz
  #+end_signature"))
#+end_src

** Viewing mail

- I'd rather word-wrap long lines when viewing mail.
- Hit =C-c C-o= to open a URL in the browser.
- I don't need to see the context of a thread (with all the deleted messages) in
  my inbox.
- Display the sender's email address along with their name.
- Save attachments in my =~/downloads= directory, not my home directory.
- While HTML emails are just fundamentally awful, we usually still need to read
  them. Tweaking =shr= settings ensures that their formatting in Emacs isn't too
  hideous.
- Some HTML emails are just too messy to display in Emacs. This binds =a h= to
  open the current email in my default Web browser.

#+begin_src emacs-lisp
  (use-package mu4e-view
    :after mu4e
    :load-path "~/media/code/mu/build/mu4e"
    :hook (mu4e-view-mode . visual-line-mode)
    :bind (:map mu4e-view-mode-map ("C-c C-o" . shr-browse-url))

    :custom
    (mu4e-headers-include-related nil)
    (mu4e-view-show-addresses t)
    (mu4e-attachment-dir "~/downloads")

    (mu4e-html2text-command 'mu4e-shr2text)
    (shr-color-visible-luminance-min 60)
    (shr-color-visible-distance-min 5)
    (shr-use-fonts nil)
    (shr-use-colors nil)

    :config
    (advice-add #'shr-colorize-region
                :around (defun shr-no-colorize-region (&rest ignore)))
    (add-to-list 'mu4e-view-actions
                 '("html in browser" . mu4e-action-view-in-browser)
                 t)

    (+bind-scroll-keys mu4e-view-mode-map))
#+end_src

** Archiving mail

Marking a message for deletion applies the "Trashed" flag. This is unfortunate,
since Fastmail will automatically delete any messages with that flag (as is the
IMAP standard).

I want to archive my messages, not delete them, so I've rebound =d= to move
email to my "Archive" folder without applying that flag.

#+begin_src emacs-lisp
  (fset '+mu4e-move-to-archive "ma")
  (evil-define-key 'normal mu4e-headers-mode-map (kbd "d") '+mu4e-move-to-archive)
  (evil-define-key 'normal mu4e-view-mode-map (kbd "d") '+mu4e-move-to-archive)
#+end_src

** Sending mail over SMTP

I send my email through =msmtp=. These settings describe how to send a message:

- Use a sendmail program instead of sending directly from Emacs,
- Tell =msmtp= to infer the correct account from the =From:= address,
- Don't add a "=-f username=" flag to the =msmtp= command, and
- Use =/usr/bin/msmtp=!

#+begin_src emacs-lisp
  (use-package sendmail
    :after mu4e
    :custom
    (message-send-mail-function 'message-send-mail-with-sendmail)
    (message-sendmail-extra-arguments '("--read-envelope-from"))
    (message-sendmail-f-is-evil 't)
    (sendmail-program "msmtp"))
#+end_src

** Agenda integration

=mu4e-org= lets me store Org links to emails. I use this to reference emails in my
TODO list while keeping my inbox empty.

When storing a link to a message in the headers view, link to the message
instead of the search that resulted in that view.

#+begin_src emacs-lisp
  (use-package mu4e-org
    :after (mu4e org)
    :load-path "~/media/code/mu/build/mu4e"
    :custom
    (mu4e-org-link-query-in-headers-mode nil))
#+end_src

** Configure =org-contacts= with =mu4e=

Use an =org-contacts= file to manage my address book.

 #+begin_src emacs-lisp
   (use-package org-contacts
     :load-path "resources"
     :after (mu4e org)
     :custom
     (org-contacts-files '("~/documents/contacts.org"))

     :config
     (setq mu4e-org-contacts-file (car org-contacts-files))
     (add-to-list 'mu4e-headers-actions
                  '("org-contact-add" . mu4e-action-add-org-contact) t)
     (add-to-list 'mu4e-view-actions
                  '("org-contact-add" . mu4e-action-add-org-contact) t))
 #+end_src

* RSS with =elfeed=

I use =elfeed= to read my (300-odd!) feeds.

- Sort RSS feeds first by tag (=comics= come before =haskell=, for example), then by
  name of the feed, and finally by publication date.
- Increase the max number of simultaneous connections to 32.

#+begin_src emacs-lisp
  (use-package elfeed
    :after writing-mode
    :commands (elfeed elfeed-update)
    :custom
    (elfeed-search-title-max-width 120)

    :config
    (evil-define-key 'normal elfeed-show-mode-map (kbd "U") 'elfeed-show-tag--unread)

    (defun +custom-elfeed-sort (a b)
      (let* ((a-tags (format "%s" (elfeed-entry-tags a)))
             (b-tags (format "%s" (elfeed-entry-tags b)))
             (a-title (elfeed-feed-title (elfeed-entry-feed a)))
             (b-title (elfeed-feed-title (elfeed-entry-feed b))))
        (if (string= a-tags b-tags)
            (if (string= a-title b-title)
                (< (elfeed-entry-date b) (elfeed-entry-date a))
              (string< b-title a-title))
          (string< a-tags b-tags))))
    (setf elfeed-search-sort-function #'+custom-elfeed-sort)

    (defun +elfeed-entry-reformat (buff)
      (switch-to-buffer buff)
      (writing-mode 1)
      (elfeed-show-refresh))
    (setq elfeed-show-entry-switch '+elfeed-entry-reformat)

    (+bind-scroll-keys elfeed-show-mode-map)

    (elfeed-set-max-connections 32))
#+end_src

Open =elfeed= with =C-c r=.

#+begin_src emacs-lisp
  (global-set-key (kbd "C-c r") 'elfeed)
#+end_src

I store my feeds in an Org file, of course. This parses them into something
=elfeed= understands.

#+begin_src emacs-lisp
  (use-package elfeed-org
    :after (elfeed org)
    :init
    (elfeed-org)
    (setq rmh-elfeed-org-files (list "~/documents/rss-feeds.org")))
#+end_src

I don't subscribe to many YouTube channels, but I use =elfeed-tube= to load items
with some associated metadata (descriptions, transcripts, etc).

#+begin_src emacs-lisp
  (use-package elfeed-tube
    :after elfeed
    :demand t
    :config
    (elfeed-tube-setup))
#+end_src

* Browsing the Web

I use Firefox to browse the Web, but I'd like to open [[https://gemini.circumlunar.space/][Gemini]] links in =elpher=.
This checks the prefix of each URL and uses the appropriate program to open it.

#+begin_src emacs-lisp
  (use-package elpher
    :commands (elpher-go)
    :config
    (+bind-scroll-keys elpher-mode-map))

  (use-package eww
    :config
    (+bind-scroll-keys eww-mode-map))

  (setq +gemini-browser 'elpher-go)

  (defun +browse-url (url &rest args)
    (if (s-prefix? "gemini:" url)
        (funcall +gemini-browser url)
      (browse-url-default-browser url args)))

  (setq browse-url-browser-function '+browse-url)
#+end_src

Exporting Org files to HTML and opening the result triggers
=/usr/bin/sensible-browser=, which checks the =$BROWSER= environment variable to
choose the right browser. I'd like to always use Firefox for that, so:

#+begin_src emacs-lisp
  (setenv "BROWSER" "firefox")
#+end_src

** =engine-mode=

I sometimes use [[https://github.com/hrs/engine-mode][=engine-mode=]] to (mostly) look up error messages.

#+begin_src emacs-lisp
  (use-package engine-mode
    :config
    (engine-mode t)

    (defengine duckduckgo
      "https://duckduckgo.com/?q=%s"
      :keybinding "/")

    (defengine wikipedia
      "http://www.wikipedia.org/search-redirect.php?search=%s&language=en&go=Go"
      :keybinding "w"))
#+end_src

* Writing prose

I write prose in several modes: I might be editing an Org document, or a commit
message, or an email. These are the main ones, with sub-items being /derived/ from
their parents:

- =git-commit-mode=
- =text-mode=
  - =markdown-mode=
    - =gfm-mode=
  - =message-mode=
    - =mu4e-compose-mode=
  - =org-mode=

Recall that derived modes "inherit" their parent's hooks, so a hook added onto
e.g. =text-mode= will also be executed by =mu4e-compose-mode=.

There are some exceptions, but I can usually associate a hook with every
prose-related mode, so I store those in a list:

#+begin_src emacs-lisp
  (defvar prose-modes
    '(gfm-mode
      git-commit-mode
      markdown-mode
      message-mode
      mu4e-compose-mode
      org-mode
      text-mode))

  (defvar prose-mode-hooks
    (mapcar (lambda (mode) (intern (format "%s-hook" mode)))
            prose-modes))
#+end_src

** Enable spell-checking in the usual places

I want to make sure that I've enabled spell-checking if I'm editing text,
composing an email, or authoring a Git commit.

#+begin_src emacs-lisp
  (use-package flyspell
    :ensure-system-package ispell
    :config
    (setq ispell-personal-dictionary "~/.ispell_words")
    (dolist (hook prose-mode-hooks)
      (add-hook hook 'flyspell-mode)))
#+end_src

** Wrap paragraphs automatically

=AutoFillMode= automatically wraps paragraphs, kinda like hitting =M-q=. I wrap a
lot of paragraphs, so this automatically wraps 'em when I'm writing text,
Markdown, or Org.

#+begin_src emacs-lisp
  (dolist (hook prose-mode-hooks)
    (add-hook hook 'turn-on-auto-fill))
#+end_src

** Use Org-style lists and tables everywhere

Enable Org-style tables.

#+begin_src emacs-lisp
  (add-hook 'markdown-mode-hook 'orgtbl-mode)
  (add-hook 'message-mode-hook 'orgtbl-mode)
#+end_src

Use the [[https://elpa.gnu.org/packages/orgalist.html][=orgalist=]] package for more convenient list manipulation.

#+begin_src emacs-lisp
  (use-package orgalist
    :hook ((git-commit-mode markdown-mode message-mode) . orgalist-mode))
#+end_src

** Linting prose

I've been using [[https://github.com/errata-ai/vale][vale]] as a prose linter, and it's not been bad so far. There's a
package that integrates it with =flycheck=, but it doesn't seem to work, so I've
got some code here to do it manually.

#+begin_src emacs-lisp
  (flycheck-define-checker vale
    "A checker for prose"
    :command ("vale" "--output" "line"
              source)
    :standard-input nil
    :error-patterns
    ((error line-start (file-name) ":" line ":" column ":" (id (one-or-more (not (any ":")))) ":" (message) line-end))
    :modes prose-modes)

  (add-to-list 'flycheck-checkers 'vale 'append)
#+end_src

** Activate =prose-assistant-mode=

I wrote [[file:resources/prose-assistant-mode.el][this global minor mode]] to let me quickly trigger a handful of common
tools I reach for while writing prose (dictionaries, word counting, etymologies,
spellchecking, translation, that sort of thing).

#+begin_src emacs-lisp
  (use-package prose-assistant-mode
    :load-path "resources"
    :bind ("<f10>" . prose-assistant-menu)
    :config
    (prose-assistant-mode t))
#+end_src

** Activate =writing-mode=

This minor mode enables a distraction-free writing environment. It enables a
whole bunch of pretty modes, switches fonts, enables inline images, and even
displays the word count in the mode-line. Toggle it with =<f9>=.

#+begin_src emacs-lisp
  (use-package mixed-pitch)
  (use-package olivetti)
  (use-package org-appear :after org)
  (use-package org-modern :after org)
  (use-package org-superstar :after org)

  (use-package wc-mode
    :custom
    (wc-modeline-format "[%tw words]")

    :config
    (unbind-key "C-c C-w" wc-mode-map)
    (add-to-list 'minions-prominent-modes 'wc-mode))

  (use-package writing-mode
    :load-path "resources"
    :defer 1
    :bind ([f9] . writing-mode)

    :config
    (require 'mixed-pitch)
    (require 'olivetti)
    (require 'org-appear)
    (require 'org-modern)
    (require 'org-superstar)
    (require 'wc-mode)

    (setq writing-enabled-modes
          '((org-mode . (org-appear-mode
                         org-modern-mode
                         org-superstar-mode))
            (elfeed-show-mode . (mixed-pitch-mode
                                 olivetti-mode))
            (special-mode . (mixed-pitch-mode
                             olivetti-mode))
            (text-mode . (flycheck-mode
                          mixed-pitch-mode
                          olivetti-mode
                          visual-line-mode
                          wc-mode)))))

  (use-package publish-mode
    :load-path "resources"
    :bind ([f8] . publish-build-and-view-pdf))
#+end_src

** Editing with Markdown

Because I can't always use =org=.

- Associate =.md= files with GitHub-flavored Markdown.
- Use =pandoc= to render the results.
- Apply syntax highlighting in code blocks.

#+begin_src emacs-lisp
  (use-package markdown-mode
    :ensure-system-package pandoc
    :commands gfm-mode
    :mode (("\\.md$" . gfm-mode))
    :config
    (custom-set-faces
     '(markdown-pre-face ((t nil))))

    (setq markdown-command "pandoc --standalone --mathjax --from=gfm"
          markdown-disable-tooltip-prompt t
          markdown-fontify-code-blocks-natively t))
#+end_src

** Cycle between spacing alternatives

Successive calls to =cycle-spacing= rotate between changing the whitespace
around point to:

- A single space,
- No spaces, or
- The original spacing.

Binding this to =M-SPC= is strictly better than the original binding of
=just-one-space=.

#+begin_src emacs-lisp
  (global-set-key (kbd "M-SPC") 'cycle-spacing)
#+end_src

** Enable region case modification

#+begin_src emacs-lisp
  (put 'downcase-region 'disabled nil)
  (put 'upcase-region 'disabled nil)
#+end_src

* Note-taking and citation management

I'm using [[https://protesilaos.com/emacs/denote][denote]] for note-taking, plus =citar= and =citar-denote= to manage
citations.

Configure a few packages to handle bibliographies and citations with =denote=
and bind keys:

- =C-c n b= :: List all the notes that link to this note.
- =C-c n c= :: Insert a citation to an existing reference in this file.
- =C-c n d= :: Suggest unlinked notes that are textually similar to this one.
- =C-c n e= :: Create a new bibliography entry.
- =C-c n f= :: Fuzzy-find a note.
- =C-c n l= :: Insert a link to another note.
- =C-c n n= :: Create a new note.
- =C-c n r= :: Prompt for an existing reference and visit or create a literature
  note associated with it.
- =C-c n s= :: Search the contents of my notes.

#+begin_src emacs-lisp
  (use-package denote
    :hook (dired-mode . denote-dired-mode)
    :bind (("C-c n b" . denote-link-find-backlink)
           ("C-c n f" . +denote-find-file)
           ("C-c n l" . denote-link)
           ("C-c n n" . denote)
           ("C-c n s" . +denote-search))

    :custom
    (denote-directory "~/documents/notes")

    :config
    (defun +denote-find-file ()
      (interactive)
      (let ((project-current-directory-override denote-directory))
        (project-find-file)))

    (defun +denote-search (term)
      (interactive (list (deadgrep--read-search-term)))
      (deadgrep term denote-directory)))
#+end_src

** Citations

I've got a single big =bibtex= file that contains all the references in my notes.
That's mostly books, but also some papers and Web sites.

I'm not in love with =bibtex-entry= as a tool for adding new references to my
database, so I wrote a few functions to do that.

#+begin_src emacs-lisp
  (use-package citar
    :custom
    (org-cite-global-bibliography '("~/documents/notes/references.bib"))

    (org-cite-insert-processor 'citar)
    (org-cite-follow-processor 'citar)
    (org-cite-activate-processor 'citar)
    (citar-bibliography org-cite-global-bibliography)

    :bind (("C-c n c" . org-cite-insert)
           ("C-c n e" . +bibliography-create-reference))

    :hook
    (LaTeX-mode . citar-capf-setup)
    (org-mode . citar-capf-setup)

    :config
    (defun +bibliography-create-reference (type)
      "Add a bibliographic reference of TYPE to the first entry in `org-cite-global-bibliography'."
      (interactive
       (list (intern
              (completing-read "Type of reference: "
                               '(article book website)))))
      (cl-case type
        (article (call-interactively '+bibliography-create-reference-article))
        (book (call-interactively '+bibliography-create-reference-book))
        (website (call-interactively '+bibliography-create-reference-www))
        (t (message "unknown reference type!"))))

    (defun +insert-bibliography-entry (type slug-components props)
      (let ((entry (concat "\n@" (prin1-to-string type) "{"
                           (+slug-for (string-join slug-components "-")) ",\n  "
                           (string-join (mapcar (lambda (p)
                                                  (concat (prin1-to-string (car p)) " = {" (cdr p) "}"))
                                                props) ",\n  ") "\n"
                           "}\n")))
        (append-to-file entry nil (car org-cite-global-bibliography))))

    (defun +bibliography-create-reference-book (title author publisher year)
      (interactive
       (list
        (read-string "Title: ")
        (read-string "Author: ")
        (read-string "Publisher: ")
        (read-string "Year: ")))

      (+insert-bibliography-entry 'book (list author year)
                                  `((title . ,title)
                                    (author . ,author)
                                    (publisher . ,publisher)
                                    (year . ,year))))

    (defun +bibliography-create-reference-article (title author year journal)
      (interactive
       (list
        (read-string "Title: ")
        (read-string "Author: ")
        (read-string "Year: ")
        (read-string "Journal: ")))

      (+insert-bibliography-entry 'article (list author year)
                                  `((title . ,title)
                                    (author . ,author)
                                    (year . ,year)
                                    (journal . ,journal))))

    (defun +bibliography-create-reference-www (url title author)
      (interactive
       (list
        (read-string "URL: " (when (string-match-p "^http" (current-kill 0))
                               (current-kill 0)))
        (read-string "Title: ")
        (read-string "Author: ")))

      (+insert-bibliography-entry 'www (list author title)
                                  `((title . ,title)
                                    (author . ,author)
                                    (url . ,url)))))
#+end_src

=citar-denote= makes it a bit easier to create and manage /literature/ notes, which
correspond to specific =bibtex= entries.

#+begin_src emacs-lisp
  (use-package citar-denote
    :hook (org-mode . citar-denote-mode)

    :bind ("C-c n r" . citar-create-note)

    :custom
    (citar-notes-paths (list denote-directory))
    (citar-denote-title-format "title"))
#+end_src

** Suggesting connections between notes

I've written a Go tool called =docsim= that uses TF-IDF document weighting and
cosine similarity to compare the text documents in a given corpus. I've also
written a little Emacs mode that wraps around that and displays the results in a
side buffer.

Calling =docsim-show-similar-notes= opens a buffer of links to nodes that are (1)
textually similar to this note, and (2) not yet linked from it.

Just an experiment so far, but I kinda intend to break this into a proper MELPA
package eventually.

#+begin_src emacs-lisp
  (use-package docsim
    :load-path "~/code/personal/docsim.el"
    :commands (docsim-show-similar-notes)
    :bind ("C-c n d" . docsim-show-similar-notes)

    :custom
    (docsim-search-paths `(,denote-directory
                           "~/documents/journal/entries"
                           "~/documents/blog/_drafts"
                           "~/documents/blog/_posts"))
    (docsim-omit-denote-links t)

    :config
    (evil-define-key 'normal docsim-mode-map (kbd "RET") 'docsim--visit-link)
    (evil-define-key 'normal docsim-mode-map (kbd "q") 'docsim--quit-sidebuffer))
#+end_src

* File management with =dired=

I've started using =dired= as my primary file manager. About time, huh?

- Set some specific =ls= switches:
  - Use the long listing format.
  - Sort numbers naturally.
  - Don't include the owner or group names.
  - Use human-readable sizes.
  - Format timestamps as =YYYY-MM-DD=.
  - Include hidden files, but /don't/ include "=.=" or "=..=".
- Kill buffers of files/directories that are deleted in =dired=.
- When I've got two =dired= windows side-by-side, and I move or copy files in one
  window, set the default location to the other window.
- Always copy directories recursively instead of asking every time.
- Do please ask before recursively /deleting/ a directory, though.
- Enable =auto-revert-mode= in =dired= buffers (so when a directory's contents are
  modified the results are reflected in the buffer automatically).

I'm often browsing directories of photos and images, so this also binds "=v=" to
view a slideshow of the current directory with =s= (a custom =feh= wrapper [[file:~/.dotfiles/bash/dot-bin/s][defined
elsewhere in this repo]]).

#+begin_src emacs-lisp
  (use-package dired
    :demand t
    :ensure nil
    :hook (dired-mode . (lambda () (undo-tree-mode 1)))

    :config
    (defun +dired-slideshow ()
      (interactive)
      (start-process "dired-slideshow" nil "s" (dired-current-directory)))

    (evil-define-key 'normal dired-mode-map (kbd "o") 'dired-find-file-other-window)
    (evil-define-key 'normal dired-mode-map (kbd "p") 'transient-extras-lp-menu)
    (evil-define-key 'normal dired-mode-map (kbd "v") '+dired-slideshow)

    (setq-default dired-listing-switches
                  (combine-and-quote-strings '("-l"
                                               "-v"
                                               "-g"
                                               "--no-group"
                                               "--human-readable"
                                               "--time-style=+%Y-%m-%d"
                                               "--almost-all")))

    (setq dired-clean-up-buffers-too t
          dired-dwim-target t
          dired-recursive-copies 'always
          dired-recursive-deletes 'top
          global-auto-revert-non-file-buffers t
          auto-revert-verbose nil))
#+end_src

Hide dotfiles by default, but toggle their visibility with "=.=". This conflicts
with =evil-repeat=, but in practice I never use that with =dired=, so the mnemonic
is worth it for me.

#+begin_src emacs-lisp
  (use-package dired-hide-dotfiles
    :demand t
    :config
    (dired-hide-dotfiles-mode 1)
    (evil-define-key 'normal dired-mode-map "." 'dired-hide-dotfiles-mode))
#+end_src

Open media with the appropriate programs.

#+begin_src emacs-lisp
  (use-package dired-open
    :demand t
    :ensure-system-package (abiword
                            feh
                            (ffplay . ffmpeg)
                            gnumeric
                            mpv
                            zathura)
    :config
    (setq dired-open-extensions
          `(("avi" . "mpv")
            ("cbr" . "zathura")
            ("cbz" . "zathura")
            ("doc" . "abiword")
            ("docx" . "abiword")
            ("epub" . "foliate")
            ("flac" . "mpv")
            ("gif" . "ffplay")
            ("gnumeric" . "gnumeric")
            ("jpeg" . ,(executable-find "s"))
            ("jpg" . ,(executable-find "s"))
            ("m4a" . "mpv")
            ("mkv" . "mpv")
            ("mobi" . "foliate")
            ("mov" . "mpv")
            ("mp3" . "mpv")
            ("mp4" . "mpv")
            ("pdf" . "zathura")
            ("png" . ,(executable-find "s"))
            ("webm" . "mpv")
            ("webp" . ,(executable-find "s"))
            ("wmv" . "mpv")
            ("xcf" . "gimp")
            ("xls" . "gnumeric")
            ("xlsx" . "gnumeric"))))
#+end_src

Files are normally moved and copied synchronously. This is fine for small or
local files, but copying a large file or moving a file across a mounted network
drive blocks Emacs until the process is completed. Unacceptable!

This uses =emacs-async= to make =dired= perform actions asynchronously.

#+begin_src emacs-lisp
  (use-package async
    :demand t

    :config
    (dired-async-mode 1))
#+end_src

* Editing settings

** Quickly visit Emacs configuration

I futz around with my dotfiles a lot. This binds =C-c e= to quickly open my
Emacs configuration file.

#+begin_src emacs-lisp
  (defun +visit-emacs-config ()
    (interactive)
    (find-file (concat user-emacs-directory "configuration.org")))

  (global-set-key (kbd "C-c e") '+visit-emacs-config)
#+end_src

** Always kill current buffer

Assume that I always want to kill the current buffer when hitting =C-x k=.

#+begin_src emacs-lisp
  (defun +kill-current-buffer ()
    "Kill the current buffer without prompting."
    (interactive)
    (kill-buffer (current-buffer)))

  (global-set-key (kbd "C-x k") '+kill-current-buffer)
#+end_src

** Set up =helpful=

The =helpful= package provides, among other things, more context in Help
buffers.

#+begin_src emacs-lisp
  (use-package helpful
    :commands (helpful-callable helpful-variable helpful-key)
    :bind
    ("C-h f" . 'helpful-callable)
    ("C-h v" . 'helpful-variable)
    ("C-h k" . 'helpful-key)

    :config
    (evil-define-key 'normal helpful-mode-map (kbd "q") 'quit-window))
#+end_src

** Save my location within a file

Using =save-place-mode= saves the location of point for every file I visit. If I
close the file or close the editor, then later re-open it, point will be at the
last place I visited.

#+begin_src emacs-lisp
  (setq save-place-forget-unreadable-files nil)
  (save-place-mode 1)
#+end_src

** Always indent with spaces

Never use tabs. Tabs are the devil's whitespace.

#+begin_src emacs-lisp
  (setq-default indent-tabs-mode nil)
#+end_src

** Install and configure =which-key=

=which-key= displays the possible completions for a long keybinding. That's
really helpful for some modes (like =project.el=, for example).

#+begin_src emacs-lisp
  (use-package which-key
    :demand t
    :config (which-key-mode))
#+end_src

** Configure =yasnippet=

I always want =yasnippet= enabled.

I /don’t/ want =yas= to always indent the snippets it inserts. Sometimes this looks
pretty bad (when indenting =org-mode=, for example, or trying to guess at the
correct indentation for Python).

#+begin_src emacs-lisp
  (use-package yasnippet
    :demand t
    :config
    (setq yas-indent-line 'auto)
    (yas-global-mode 1))
#+end_src

** Configure =ivy= and =counsel=

I use =ivy= and =counsel= as my completion framework.

This configuration:

- Uses =counsel-M-x= for command completion,
- Replaces =isearch= with =swiper=,
- Uses =smex= to maintain history,
- Enables fuzzy matching everywhere except swiper (where it's thoroughly
  unhelpful), and
- Includes recent files in the switch buffer.

#+begin_src emacs-lisp
  (use-package counsel
    :demand t
    :bind
    ("M-x" . 'counsel-M-x)
    ("C-x b" . 'counsel-switch-buffer)
    ("C-x C-f" . 'counsel-find-file)
    ("C-s" . 'swiper)

    :config
    (use-package flx)
    (use-package smex)

    (ivy-mode 1)
    (setq ivy-use-virtual-buffers t)
    (setq ivy-count-format "(%d/%d) ")
    (setq ivy-initial-inputs-alist nil)
    (setq ivy-re-builders-alist
          '((swiper . ivy--regex-plus)
            (t . ivy--regex-fuzzy))))
#+end_src

Add descriptions to the =ivy= buffer.

#+begin_src emacs-lisp
  (use-package ivy-rich
    :init
    (ivy-rich-mode 1)
    (ivy-rich-project-root-cache-mode 1))
#+end_src

** Switch and rebalance windows when splitting

When splitting a window, I invariably want to switch to the new window. This
makes that automatic. Similarly, when closing a window I'd like to rebalance the
remaining windows.

#+begin_src emacs-lisp
  (defun +split-window-below-and-switch ()
    "Split the window horizontally, then switch to the new pane."
    (interactive)
    (split-window-below)
    (balance-windows)
    (other-window 1))

  (defun +split-window-right-and-switch ()
    "Split the window vertically, then switch to the new pane."
    (interactive)
    (split-window-right)
    (balance-windows)
    (other-window 1))

  (defun +delete-window-and-rebalance ()
    "Delete the current window, then rebalance the remaining windows."
    (interactive)
    (delete-window)
    (balance-windows))

  (global-set-key (kbd "C-x 2") '+split-window-below-and-switch)
  (global-set-key (kbd "C-x 3") '+split-window-right-and-switch)
  (global-set-key (kbd "C-x 0") '+delete-window-and-rebalance)
#+end_src

** Mass editing of =grep= results

I like the idea of mass editing =grep= results the same way I can edit filenames
in =dired=. These keybindings allow me to use =C-x C-q= to start editing =grep=
results and =C-c C-c= to stop, just like in =dired=.

#+begin_src emacs-lisp
  (use-package wgrep)

  (eval-after-load 'grep
    '(define-key grep-mode-map
      (kbd "C-x C-q") 'wgrep-change-to-wgrep-mode))

  (eval-after-load 'wgrep
    '(define-key grep-mode-map
      (kbd "C-c C-c") 'wgrep-finish-edit))

  (setq wgrep-auto-save-buffer t)
#+end_src

** Reformat typographic symbols and HTML entities to plain text

I sometimes need to convert some copied text containing typographic symbols like
curly quotes and em-dashes into ASCII text. Similarly, I'll sometimes need to do
that with HTML entities, too. This provides functions to do that within a
specified region.

#+begin_src emacs-lisp
  (defvar +typographic-replacements
    '(("…" . "...")
      ("‘" . "'")
      ("’" . "'")
      ("“" . "\"")
      ("”" . "\"")
      ("–" . "--")
      ("—" . "---")))

  (defvar +html-entity-replacements
    '(("&amp;" . "&")
      ("&nbsp;" . " ")
      ("&lsquo;" . "'")
      ("&rsquo;" . "'")
      ("&apos;" . "'")
      ("&ldquo;" . "\"")
      ("&rdquo;" . "\"")
      ("&quot;" . "\"")
      ("&lt;" . "<")
      ("&gt;" . ">")))

  (defun +replace-symbols (replacements)
    (save-restriction
      (when (region-active-p)
        (narrow-to-region (region-beginning) (region-end)))
      (dolist (pair replacements)
        (goto-char (point-min))
        (while (search-forward (car pair) nil t)
          (replace-match (cdr pair))))))

  (defun +replace-typographic-symbols ()
    "Replace common typographic symbols in the region or buffer with their ASCII equivalents."
    (interactive)
    (+replace-symbols +typographic-replacements))

  (defun +replace-html-entities ()
    "Replace common HTML entities in the region or buffer with their ASCII equivalents."
    (interactive)
    (+replace-symbols +html-entity-replacements))
#+end_src

** Edit files as =sudo=

I always forget the TRAMP syntax, and this provides the easier-to-remember
=sudo-edit= function.

#+begin_src emacs-lisp
  (use-package sudo-edit
    :commands (sudo-edit))
#+end_src

* Printing

Sometimes I like reading dead trees.

#+begin_src emacs-lisp
  (use-package transient-extras-lp
    :commands (transient-extras-lp-menu)

    :custom
    (transient-extras-lp-saved-options '("-dBrother_HL_L2340D_series"
                                         "-osides=two-sided-long-edge"
                                         "-omedia=letter")))
#+end_src

* Set custom keybindings

Just a few handy functions.

#+begin_src emacs-lisp
  (global-set-key (kbd "C-w") 'backward-kill-word)
  (global-set-key (kbd "M-o") 'other-window)
  (global-set-key (kbd "C-x C-b") 'ibuffer)
#+end_src

Remap when working in terminal Emacs.

#+begin_src emacs-lisp
  (define-key input-decode-map "\e[1;2A" [S-up])
#+end_src

* Extra

Show battery status in the modeline if I'm on a laptop and not using a GUI.

#+begin_src emacs-lisp
  (use-package battery
    :if (not (display-graphic-p))
    :config
    (when (and battery-status-function
               (not (string-match-p "unknown"
                                    (battery-format "%B" (funcall battery-status-function)))))
      (display-battery-mode 1)))
#+end_src

Load any extra bits and bobs.

#+begin_src emacs-lisp
  (when (file-exists-p (concat user-emacs-directory "private.el"))
    (load-file (concat user-emacs-directory "private.el")))
#+end_src

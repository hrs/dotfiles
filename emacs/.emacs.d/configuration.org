#+TITLE: Emacs Configuration
#+AUTHOR: Harry R. Schwartz
#+EMAIL: hello@harryrschwartz.com
#+OPTIONS: toc:nil num:nil

* Configure =use-package=

I use =use-package= to install and configure my packages. My =init.el= includes
the initial setup for =package.el= and ensures that =use-package= is installed,
since I wanna do that right away.

This makes sure that =use-package= will install the package if it's not already
available. It also means that I should be able to open Emacs for the first time
on a fresh Debian box and have my whole environment automatically installed. I'm
not /totally/ sure about that, but we're gettin' close.

#+begin_src emacs-lisp
  (require 'use-package-ensure)
  (setq use-package-always-ensure t)
#+end_src

Always compile packages, and use the newest version available.

#+begin_src emacs-lisp
  (use-package auto-compile
    :config (auto-compile-on-load-mode))

  (setq load-prefer-newer t)
#+end_src

Disable TLS 1.3; ELPA has higher standards. That'll be the default in Emacs
26.3, I think, but I'm not there yet.

#+begin_src emacs-lisp
  (setq gnutls-algorithm-priority "NORMAL:-VERS-TLS1.3")
#+end_src

* Use sensible-defaults.el

Use [[https://github.com/hrs/sensible-defaults.el][sensible-defaults.el]] for some basic settings.

#+begin_src emacs-lisp
  (load-file "~/code/personal/sensible-defaults.el/sensible-defaults.el")
  (sensible-defaults/use-all-settings)
  (sensible-defaults/use-all-keybindings)
  (sensible-defaults/backup-to-temp-directory)
#+end_src

* Set personal information

** Who am I? Where am I?

#+begin_src emacs-lisp
  (setq user-full-name "Harry R. Schwartz"
        user-mail-address "hello@harryrschwartz.com"
        calendar-latitude 40.00
        calendar-longitude -105.16
        calendar-location-name "Boulder, CO")
#+end_src

** Access my netrc data

I store a few credentials in a =.netrc= file. Actually, I think the only creds I
have in there right now are for Instapaper, but this is still a convenient way
to store not-too-terribly-sensitive secrets.

#+begin_src emacs-lisp
  (require 'netrc)

  (setq netrc-file "~/.netrc")

  (defun netrc-username (machine)
    "Helper function to extract a username from my netrc."
    (car (netrc-credentials machine)))

  (defun netrc-password (machine)
    "Helper function to extract a password from my netrc."
    (cadr (netrc-credentials machine)))
#+end_src

* Add =resources= to =load-path=

#+begin_src emacs-lisp
  (add-to-list 'load-path "~/.emacs.d/resources/")
#+end_src

* =evil-mode=

I'd prefer not to expand abbrevs when I hit escape. That's always jarring and
usually not what I want. In particular, it makes working with Coq really
frustrating.

#+begin_src emacs-lisp
  (setq evil-want-abbrev-expand-on-insert-exit nil)
#+end_src

Use =evil=.

#+begin_src emacs-lisp
  (use-package evil
    :config
    (evil-mode 1))
#+end_src

Install =evil-collection=, which provides evil-friendly bindings for many modes.

#+begin_src emacs-lisp
  (use-package evil-collection
    :after evil)
#+end_src

Enable =surround= everywhere.

#+begin_src emacs-lisp
  (use-package evil-surround
    :config
    (global-evil-surround-mode 1))
#+end_src

Use =evil= with Org agendas.

#+begin_src emacs-lisp
  (use-package evil-org
    :after org
    :config
    (add-hook 'org-mode-hook 'evil-org-mode)
    (add-hook 'evil-org-mode-hook
              (lambda () (evil-org-set-key-theme)))
    (require 'evil-org-agenda)
    (evil-org-agenda-set-keys))
#+end_src

* Utility functions

Define a big ol' bunch of handy utility functions.

#+begin_src emacs-lisp
  (defun hrs/rename-file (new-name)
    (interactive "FNew name: ")
    (let ((filename (buffer-file-name)))
      (if filename
          (progn
            (when (buffer-modified-p)
              (save-buffer))
            (rename-file filename new-name t)
            (kill-buffer (current-buffer))
            (find-file new-name)
            (message "Renamed '%s' -> '%s'" filename new-name))
        (message "Buffer '%s' isn't backed by a file!" (buffer-name)))))

  (defun hrs/generate-scratch-buffer ()
    "Create and switch to a temporary scratch buffer with a random
         name."
    (interactive)
    (switch-to-buffer (make-temp-name "scratch-")))

  (defun hrs/kill-current-buffer ()
    "Kill the current buffer without prompting."
    (interactive)
    (kill-buffer (current-buffer)))

  (defun hrs/visit-last-migration ()
    "Open the most recent Rails migration. Relies on projectile."
    (interactive)
    (let ((migrations
           (directory-files
            (expand-file-name "db/migrate" (projectile-project-root)) t)))
      (find-file (car (last migrations)))))

  (defun hrs/add-auto-mode (mode &rest patterns)
    "Add entries to `auto-mode-alist' to use `MODE' for all given file `PATTERNS'."
    (dolist (pattern patterns)
      (add-to-list 'auto-mode-alist (cons pattern mode))))

  (defun hrs/find-file-as-sudo ()
    (interactive)
    (let ((file-name (buffer-file-name)))
      (when file-name
        (find-alternate-file (concat "/sudo::" file-name)))))

  (defun hrs/region-or-word ()
    (if mark-active
        (buffer-substring-no-properties (region-beginning)
                                        (region-end))
      (thing-at-point 'word)))

  (defun hrs/append-to-path (path)
    "Add a path both to the $PATH variable and to Emacs' exec-path."
    (setenv "PATH" (concat (getenv "PATH") ":" path))
    (add-to-list 'exec-path path))

  (defun hrs/insert-password ()
    (interactive)
    (shell-command "pwgen 30 -1" t))

  (defun hrs/notify-send (title message)
    "Display a desktop notification by shelling out to `notify-send'."
    (call-process-shell-command
     (format "notify-send -t 2000 \"%s\" \"%s\"" title message)))
#+end_src

* UI preferences
** Tweak window chrome

I don't usually use the menu or scroll bar, and they take up useful space.

#+begin_src emacs-lisp
  (tool-bar-mode 0)
  (menu-bar-mode 0)
  (scroll-bar-mode -1)
#+end_src

There's a tiny scroll bar that appears in the minibuffer window. This disables
that:

#+begin_src emacs-lisp
  (set-window-scroll-bars (minibuffer-window) nil nil)
#+end_src

The default frame title isn't useful. This binds it to the name of the current
project:

#+begin_src emacs-lisp
  (setq frame-title-format '((:eval (projectile-project-name))))
#+end_src

** Use fancy lambdas

Why not?

#+begin_src emacs-lisp
  (global-prettify-symbols-mode t)
#+end_src

** Load up a theme

I'm currently using the "solarized-dark" theme. I've got a scenic wallpaper, so
just a hint of transparency looks lovely and isn't distracting or hard to read.

#+begin_src emacs-lisp
  (use-package solarized-theme
    :config
    (setq solarized-use-variable-pitch nil
          solarized-height-plus-1 1.0
          solarized-height-plus-2 1.0
          solarized-height-plus-3 1.0
          solarized-height-plus-4 1.0)

    (let ((line (face-attribute 'mode-line :underline)))
      (set-face-attribute 'mode-line          nil :overline   line)
      (set-face-attribute 'mode-line-inactive nil :overline   line)
      (set-face-attribute 'mode-line-inactive nil :underline  line)
      (set-face-attribute 'mode-line          nil :box        nil)
      (set-face-attribute 'mode-line-inactive nil :box        nil)
      (set-face-attribute 'mode-line-inactive nil :background "#f9f2d9")))

  (defun transparency (value)
    "Sets the transparency of the frame window. 0=transparent/100=opaque."
    (interactive "nTransparency Value 0 - 100 opaque:")
    (set-frame-parameter (selected-frame) 'alpha value))

  (defun hrs/apply-theme ()
    "Apply the `solarized-light' theme and make frames just slightly transparent."
    (interactive)
    (load-theme 'solarized-light t)
    (transparency 90))
#+end_src

If this code is being evaluated by =emacs --daemon=, ensure that each subsequent
frame is themed appropriately.

#+begin_src emacs-lisp
  (if (daemonp)
      (add-hook 'after-make-frame-functions
                (lambda (frame)
                  (with-selected-frame frame (hrs/apply-theme))))
    (hrs/apply-theme))
#+end_src

** Use =moody= for a beautiful modeline

This gives me a truly lovely ribbon-based modeline.

#+begin_src emacs-lisp
  (use-package moody
    :config
    (setq x-underline-at-descent-line t)
    (moody-replace-mode-line-buffer-identification)
    (moody-replace-vc-mode))
#+end_src

** Use =minions= to hide all minor modes

I never want to see a minor mode, and manually adding =:diminish= to every
use-package declaration is a hassle. This uses =minions= to hide all the minor
modes in the modeline. Nice!

By default there's a =;-)= after the major mode; that's an adorable default, but
I'd rather skip it.

#+begin_src emacs-lisp
   (use-package minions
     :config
     (setq minions-mode-line-lighter ""
           minions-mode-line-delimiters '("" . ""))
     (minions-mode 1))
#+end_src

** Disable visual bell

=sensible-defaults= replaces the audible bell with a visual one, but I really
don't even want that (and my Emacs/Mac pair renders it poorly). This disables
the bell altogether.

#+begin_src emacs-lisp
  (setq ring-bell-function 'ignore)
#+end_src

** Scroll conservatively

When point goes outside the window, Emacs usually recenters the buffer point.
I'm not crazy about that. This changes scrolling behavior to only scroll as far
as point goes.

#+begin_src emacs-lisp
  (setq scroll-conservatively 100)
#+end_src

** Set default font and configure font resizing

I'm partial to Inconsolata.

The standard =text-scale-= functions just resize the text in the current buffer;
I'd generally like to resize the text in /every/ buffer, and I usually want to
change the size of the modeline, too (this is especially helpful when
presenting). These functions and bindings let me resize everything all together!

Note that this overrides the default font-related keybindings from
=sensible-defaults=.

#+begin_src emacs-lisp
  (setq hrs/default-font "Inconsolata")
  (setq hrs/default-font-size 11)
  (setq hrs/current-font-size hrs/default-font-size)

  (setq hrs/font-change-increment 1.1)

  (defun hrs/font-code ()
    "Return a string representing the current font (like \"Inconsolata-14\")."
    (concat hrs/default-font "-" (number-to-string hrs/current-font-size)))

  (defun hrs/set-font-size ()
    "Set the font to `hrs/default-font' at `hrs/current-font-size'.
  Set that for the current frame, and also make it the default for
  other, future frames."
    (let ((font-code (hrs/font-code)))
      (if (assoc 'font default-frame-alist)
          (setcdr (assoc 'font default-frame-alist) font-code)
        (add-to-list 'default-frame-alist (cons 'font font-code)))
      (set-frame-font font-code)))

  (defun hrs/reset-font-size ()
    "Change font size back to `hrs/default-font-size'."
    (interactive)
    (setq hrs/current-font-size hrs/default-font-size)
    (hrs/set-font-size))

  (defun hrs/increase-font-size ()
    "Increase current font size by a factor of `hrs/font-change-increment'."
    (interactive)
    (setq hrs/current-font-size
          (ceiling (* hrs/current-font-size hrs/font-change-increment)))
    (hrs/set-font-size))

  (defun hrs/decrease-font-size ()
    "Decrease current font size by a factor of `hrs/font-change-increment', down to a minimum size of 1."
    (interactive)
    (setq hrs/current-font-size
          (max 1
               (floor (/ hrs/current-font-size hrs/font-change-increment))))
    (hrs/set-font-size))

  (define-key global-map (kbd "C-)") 'hrs/reset-font-size)
  (define-key global-map (kbd "C-+") 'hrs/increase-font-size)
  (define-key global-map (kbd "C-=") 'hrs/increase-font-size)
  (define-key global-map (kbd "C-_") 'hrs/decrease-font-size)
  (define-key global-map (kbd "C--") 'hrs/decrease-font-size)

  (hrs/reset-font-size)
#+end_src

** Highlight the current line

=global-hl-line-mode= softly highlights the background color of the line
containing point. It makes it a bit easier to find point, and it's useful when
pairing or presenting code.

#+begin_src emacs-lisp
  (global-hl-line-mode)
#+end_src

** Highlight uncommitted changes

Use the =diff-hl= package to highlight changed-and-uncommitted lines when
programming.

#+begin_src emacs-lisp
  (use-package diff-hl
    :config
    (add-hook 'prog-mode-hook 'turn-on-diff-hl-mode)
    (add-hook 'vc-dir-mode-hook 'turn-on-diff-hl-mode))
#+end_src

* Project management

I use a few packages in virtually every programming or writing environment to
manage the project, handle auto-completion, search for terms, and deal with
version control. That's all in here.

** =ag=

Install =ag= to provide search within projects (usually through
=projectile-ag=).

#+begin_src emacs-lisp
  (use-package ag)
#+end_src

** =company=

Use =company-mode= everywhere.

#+begin_src emacs-lisp
  (use-package company)
  (add-hook 'after-init-hook 'global-company-mode)
#+end_src

Use =M-/= for completion.

#+begin_src emacs-lisp
  (global-set-key (kbd "M-/") 'company-complete-common)
#+end_src

** =dumb-jump=

The =dumb-jump= package works well enough in a [[https://github.com/jacktasia/dumb-jump#supported-languages][ton of environments]], and it
doesn't require any additional setup. I've bound its most useful command to
=M-.=.

#+begin_src emacs-lisp
  (use-package dumb-jump
    :config
    (define-key evil-normal-state-map (kbd "M-.") 'dumb-jump-go)
    (setq dumb-jump-selector 'ivy))
#+end_src

** =flycheck=

 #+begin_src emacs-lisp
   (use-package let-alist)
   (use-package flycheck)
 #+end_src

** =magit=

I use =magit= to handle version control. It's lovely, but I tweak a few things:

- I bring up the status menu with =C-x g=.
- Use =evil= keybindings with =magit=.
- The default behavior of =magit= is to ask before pushing. I haven't had any
  problems with accidentally pushing, so I'd rather not confirm that every time.
- Per [[http://tbaggery.com/2008/04/19/a-note-about-git-commit-messages.html][tpope's suggestions]], highlight commit text in the summary line that goes
  beyond 50 characters.
- On the command line I'll generally push a new branch with a plain old =git
  push=, which automatically creates a tracking branch on (usually) =origin=.
  Magit, by default, wants me to manually specify an upstream branch. This binds
  =P P= to =magit-push-implicitly=, which is just a wrapper around =git push
  -v=. Convenient!
- I'd like to start in the insert state when writing a commit message.

#+begin_src emacs-lisp
  (use-package magit
    :bind
    ("C-x g" . magit-status)

    :config
    (use-package evil-magit)
    (use-package with-editor)
    (setq magit-push-always-verify nil)
    (setq git-commit-summary-max-length 50)

    (with-eval-after-load 'magit-remote
      (magit-define-popup-action 'magit-push-popup ?P
        'magit-push-implicitly--desc
        'magit-push-implicitly ?p t))

    (add-hook 'with-editor-mode-hook 'evil-insert-state))
#+end_src

I've been playing around with the newly-released =forge= for managing GitHub PRs
and issues. Seems slick so far.

#+begin_src emacs-lisp
  (use-package ghub)
  (use-package forge)
#+end_src

I'm also partial to =git-timemachine=, which lets you quickly page through the
history of a file.

#+begin_src emacs-lisp
  (use-package git-timemachine)
#+end_src

** =projectile=

Projectile's default binding of =projectile-ag= to =C-c p s s= is clunky enough
that I rarely use it (and forget it when I need it). This binds it to the
easier-to-type =C-c v= to useful searches.

Bind =C-p= to fuzzy-finding files in the current project. We also need to
explicitly set that in a few other modes.

I use =ivy= as my completion system.

When I visit a project with =projectile-switch-project=, the default action is
to search for a file in that project. I'd rather just open up the top-level
directory of the project in =dired= and find (or create) new files from there.

I'd like to /always/ be able to recursively fuzzy-search for files, not just
when I'm in a Projectile-defined project. I use the current directory as a
project root (if I'm not in a "real" project).

#+begin_src emacs-lisp
  (use-package projectile
    :bind
    ("C-c v" . projectile-ag)

    :config
    (define-key projectile-mode-map (kbd "C-c p") 'projectile-command-map)

    (define-key evil-normal-state-map (kbd "C-p") 'projectile-find-file)
    (evil-define-key 'motion ag-mode-map (kbd "C-p") 'projectile-find-file)
    (evil-define-key 'motion rspec-mode-map (kbd "C-p") 'projectile-find-file)

    (setq projectile-completion-system 'ivy)
    (setq projectile-switch-project-action 'projectile-dired)
    (setq projectile-require-project-root nil))
#+end_src

** =restclient=

#+begin_src emacs-lisp
  (use-package restclient)
  (use-package company-restclient
    :config
    (add-to-list 'company-backends 'company-restclient))
#+end_src

** =undo-tree=

I like tree-based undo management. I only rarely need it, but when I do, oh boy.

#+begin_src emacs-lisp
  (use-package undo-tree)
#+end_src

* Programming environments

I like shallow indentation, but tabs are displayed as 8 characters by default.
This reduces that.

#+begin_src emacs-lisp
  (setq-default tab-width 2)
#+end_src

Treating terms in CamelCase symbols as separate words makes editing a little
easier for me, so I like to use =subword-mode= everywhere.

#+begin_src emacs-lisp
  (use-package subword
    :config (global-subword-mode 1))
#+end_src

Compilation output goes to the =*compilation*= buffer. I rarely have that window
selected, so the compilation output disappears past the bottom of the window.
This automatically scrolls the compilation window so I can always see the
output.

#+begin_src emacs-lisp
  (setq compilation-scroll-output t)
#+end_src

** Coq

I use =company-coq-mode=, which really helps make Proof General a more useful IDE.

#+begin_src emacs-lisp
  (use-package company-coq)
#+end_src

I bind the right and left arrow keys to evaluating and retracting the next and
previous statements. This is more convenient than the default bindings of =C-c
C-n= and =C-c C-u=.

I also like to disable =abbrev-mode=; it has a ton of abbreviations for Coq, but
they've always been unpleasant surprises for me.

#+begin_src emacs-lisp
  (add-hook 'coq-mode-hook
            (lambda ()
              (company-coq-mode)
              (evil-define-key 'normal coq-mode-map (kbd "<down>") 'proof-assert-next-command-interactive)
              (evil-define-key 'normal coq-mode-map (kbd "<up>") 'proof-undo-last-successful-command)
              (evil-define-key 'normal coq-mode-map (kbd "<return>") 'company-coq-proof-goto-point)
              (abbrev-mode 0)))
#+end_src

The default Proof General layout stacks the code, goal, and response buffers on
top of each other. I like to keep my code on one side and my goal and response
buffers on the other.

#+begin_src emacs-lisp
  (setq proof-three-window-mode-policy 'hybrid)
#+end_src

Don't move point when asserting and undoing proof commands.

#+begin_src emacs-lisp
  (setq proof-follow-mode 'ignore)
#+end_src

The Proof General splash screen's pretty cute, but I don't need to see it every
time.

#+begin_src emacs-lisp
  (setq proof-splash-enable nil)
#+end_src

Proof General usually evaluates each comment individually. In literate programs,
this can result in evaluating a /ton/ of comments. This evaluates a series of
consecutive comments as a single comment.

#+begin_src emacs-lisp
  (setq proof-script-fly-past-comments t)
#+end_src

** CSS, Sass, and Less

Indent by 2 spaces.

#+begin_src emacs-lisp
  (use-package css-mode
    :config
    (setq css-indent-offset 2))
#+end_src

Don't compile the current SCSS file every time I save.

#+begin_src emacs-lisp
  (use-package scss-mode
    :config
    (setq scss-compile-at-save nil))
#+end_src

Install Less.

#+begin_src emacs-lisp
  (use-package less-css-mode)
#+end_src

** Golang

Install =go-mode= and related packages:

#+begin_src emacs-lisp
  (use-package go-mode)
  (use-package go-errcheck)
  (use-package company-go)
#+end_src

Define my =$GOPATH= and tell Emacs where to find the Go binaries.

#+begin_src emacs-lisp
  (setenv "GOPATH" "/home/hrs/code/go")
  (hrs/append-to-path (concat (getenv "GOPATH") "/bin"))
#+end_src

Run =goimports= on every file when saving, which formats the file and
automatically updates the list of imports. This requires that the =goimports=
binary be installed.

#+begin_src emacs-lisp
  (setq gofmt-command "goimports")
  (add-hook 'before-save-hook 'gofmt-before-save)
#+end_src

When I open a Go file,

- Start up =company-mode= with the Go backend. This requires that the =gocode=
  binary is installed,
- Redefine the default =compile= command to something Go-specific, and
- Enable =flycheck=.

#+begin_src emacs-lisp
  (add-hook 'go-mode-hook
            (lambda ()
              (set (make-local-variable 'company-backends)
                   '(company-go))
              (company-mode)
              (if (not (string-match "go" compile-command))
                  (set (make-local-variable 'compile-command)
                       "go build -v && go test -v && go vet"))
              (flycheck-mode)))
#+end_src

** Haml and Slim

Install the Haml and Slim packages.

#+begin_src emacs-lisp
  (use-package haml-mode)
  (use-package slim-mode)
#+end_src

If I'm editing Haml or Slim templates I'm probably in a Rails project. In that
case, I'd like to still be able to run my tests from the appropriate buffers.

#+begin_src emacs-lisp
  (add-hook 'slim-mode-hook 'rspec-mode)
  (add-hook 'haml-mode-hook 'rspec-mode)
#+end_src

** Haskell

#+begin_src emacs-lisp
  (use-package haskell-mode)
#+end_src

Enable =haskell-doc-mode=, which displays the type signature of a function, and
use smart indentation.

#+begin_src emacs-lisp
  (add-hook 'haskell-mode-hook
            (lambda ()
              (haskell-doc-mode)
              (turn-on-haskell-indent)))
#+end_src

#+begin_src emacs-lisp
  (hrs/append-to-path "~/.cabal/bin")
#+end_src

** JavaScript and CoffeeScript

Install =coffee-mode= from editing CoffeeScript code.

#+begin_src emacs-lisp
  (use-package coffee-mode)
#+end_src

Indent everything by 2 spaces.

#+begin_src emacs-lisp
  (setq js-indent-level 2)

  (add-hook 'coffee-mode-hook
            (lambda ()
              (yas-minor-mode 1)
              (setq coffee-tab-width 2)))
#+end_src

** Lisps

*** Racket

#+begin_src emacs-lisp
  (use-package racket-mode)
#+end_src

[[https://docs.racket-lang.org/pollen/][Pollen]] uses a lozenge ◊ to mark preprocessor commands (like defining and
dereferencing variables). That's awkward to type, so this lets me hit =M-^= to
insert one.

#+begin_src emacs-lisp
  (defun hrs/insert-lozenge ()
    (interactive)
    (insert "◊"))

  (define-key racket-mode-map (kbd "M-^") 'hrs/insert-lozenge)
#+end_src

*** All Lisps

I like to use =paredit= in Lisp modes to balance parentheses (and more!).

#+begin_src emacs-lisp
  (use-package paredit)
#+end_src

=rainbow-delimiters= is convenient for coloring matching parentheses.

#+begin_src emacs-lisp
  (use-package rainbow-delimiters)
#+end_src

All the lisps have some shared features, so we want to do the same things for
all of them. That includes using =paredit=, =rainbow-delimiters=, and
highlighting the whole expression when point is on a parenthesis.

#+begin_src emacs-lisp
  (setq lispy-mode-hooks
        '(clojure-mode-hook
          emacs-lisp-mode-hook
          lisp-mode-hook
          scheme-mode-hook))

  (dolist (hook lispy-mode-hooks)
    (add-hook hook (lambda ()
                     (setq show-paren-style 'expression)
                     (paredit-mode)
                     (rainbow-delimiters-mode))))
#+end_src

If I'm writing in Emacs lisp I'd like to use =eldoc-mode= to display
documentation.

#+begin_src emacs-lisp
  (use-package eldoc
    :config
    (add-hook 'emacs-lisp-mode-hook 'eldoc-mode))
#+end_src

I also like using =flycheck-package= to ensure that my Elisp packages are
correctly formatted.

#+begin_src emacs-lisp
  (use-package flycheck-package)

  (eval-after-load 'flycheck
    '(flycheck-package-setup))
#+end_src

** OCaml

Use =tuareg-mode= for editing OCaml.

#+begin_src emacs-lisp
  (use-package tuareg
    :config
    (electric-indent-mode 0))
#+end_src

Configure Merlin. This also requires installing the Merlin package through OPAM
with =opam install merlin=.

#+begin_src emacs-lisp
  (use-package merlin
    :config
    (add-hook 'tuareg-mode-hook 'merlin-mode t)

    (with-eval-after-load 'company
      (add-to-list 'company-backends 'merlin-company-backend))
    (add-hook 'merlin-mode-hook 'company-mode))
#+end_src

** Python

#+begin_src emacs-lisp
  (use-package python-mode)
#+end_src

Add =~/.local/bin= to load path. That's where =virtualenv= is installed, and
we'll need that for =jedi=.

#+begin_src emacs-lisp
  (hrs/append-to-path "~/.local/bin")
#+end_src

Enable =elpy=. This provides automatic indentation, auto-completion, syntax
checking, etc.

#+begin_src emacs-lisp
  (use-package elpy)
  (elpy-enable)
#+end_src

Use =flycheck= for syntax checking:

#+begin_src emacs-lisp
  (add-hook 'elpy-mode-hook 'flycheck-mode)
#+end_src

Format code according to PEP8 on save:

#+begin_src emacs-lisp
  (use-package py-autopep8)
  (require 'py-autopep8)
  (add-hook 'elpy-mode-hook 'py-autopep8-enable-on-save)
#+end_src

Configure Jedi along with the associated =company= mode:

#+begin_src emacs-lisp
  (use-package company-jedi)
  (add-to-list 'company-backends 'company-jedi)

  (add-hook 'python-mode-hook 'jedi:setup)
  (setq jedi:complete-on-dot t)
#+end_src

** Ruby and RSpec

I use =chruby= to switch between versions of Ruby. This sets a default version
to use within Emacs (for things like =xmp= or =rspec=).

#+begin_src emacs-lisp
  (setq hrs/ruby-version "2.7.0")

  (use-package chruby
    :config
    (chruby hrs/ruby-version))
#+end_src

Ruby executables are installed in =~/.gem/ruby/<version>/bin=. This ensures that
that's included in the path. In particular, we want that directory to be
included because it contains the =xmpfilter= executable, which is used below.

#+begin_src emacs-lisp
  (hrs/append-to-path (format "~/.gem/ruby/%s/bin" hrs/ruby-version))
#+end_src

Running tests from within Emacs is awfully convenient.

#+begin_src emacs-lisp
  (use-package rspec-mode)
#+end_src

=rcodetools= provides =xmp=, which lets me evaluate a Ruby buffer and display
the results in "magic" (=# =>=) comments.

I disable warnings when running code through =xmp= because I disagree with a few
of them (complaining about private =attr_reader=, especially) and they gunk up
my buffer.

#+begin_src emacs-lisp
  (setq xmpfilter-command-name
        "ruby -S xmpfilter --no-warnings --dev --fork --detect-rbtest")
  (require 'rcodetools)
#+end_src

I like running Rubocop through Flycheck, but it also invokes Reek, which I've
found to be more of a nuisance than a help. This disables the =ruby-reek=
checker:

#+begin_src emacs-lisp
  (setq-default flycheck-disabled-checkers '(ruby-reek))
#+end_src

When assigning the result of a conditional, I like to align the expression to
match the beginning of the statement instead of indenting it all the way to the
=if=.

#+begin_src emacs-lisp
  (setq ruby-align-to-stmt-keywords '(def if))
#+end_src

Ruby method comments are often formatted with Yard.

#+begin_src emacs-lisp
  (use-package yard-mode)
#+end_src

Insert =end= keywords automatically when I start to define a method, class,
module, or block.

#+begin_src emacs-lisp
  (use-package ruby-end)
#+end_src

Install and enable =projectile-rails= mode in all Rail-related buffers.

#+begin_src emacs-lisp
  (use-package projectile-rails
    :config
    (projectile-rails-global-mode))
#+end_src

There are a bunch of things I'd like to do when I open a Ruby buffer:

- I don't want to insert an encoding comment.
- I want to enable =yas=, =rspec=, =yard=, =flycheck=, and =projectile-rails=.
- I'd like my RSpec tests to be run in a random order, and I'd like the output
  to be colored.
- Chruby should automatically determine the correct version for me.
- =C-c C-c= should run =xmp=, to do that nifty "eval into comments" trick.

#+begin_src emacs-lisp
  (add-hook 'ruby-mode-hook
            (lambda ()
              (setq ruby-insert-encoding-magic-comment nil)
              (yas-minor-mode)
              (rspec-mode)
              (yard-mode)
              (flycheck-mode)
              (local-set-key "\r" 'newline-and-indent)
              (setq rspec-command-options "--color --order random")
              (chruby-use-corresponding)
              (define-key ruby-mode-map (kbd "C-c C-c") 'xmp)))
#+end_src

I associate =ruby-mode= with Gemfiles, gemspecs, Rakefiles, and Vagrantfiles.

#+begin_src emacs-lisp
  (hrs/add-auto-mode
   'ruby-mode
   "\\Gemfile$"
   "\\.rake$"
   "\\.gemspec$"
   "\\Guardfile$"
   "\\Rakefile$"
   "\\Vagrantfile$"
   "\\Vagrantfile.local$")
#+end_src

When running RSpec tests I'd like to scroll to the first error.

#+begin_src emacs-lisp
  (add-hook 'rspec-compilation-mode-hook
            (lambda ()
              (make-local-variable 'compilation-scroll-output)
              (setq compilation-scroll-output 'first-error)))
#+end_src

** Rust

Use =rust-mode= to edit Rust code.

Run =rustfmt= automatically when saving a file.

#+begin_src emacs-lisp
  (use-package rust-mode
    :config
    (hrs/append-to-path "~/.cargo/bin")
    (setq rust-format-on-save t))
#+end_src

** =sh=

Indent with 2 spaces.

#+begin_src emacs-lisp
  (add-hook 'sh-mode-hook
            (lambda ()
              (setq sh-basic-offset 2
                    sh-indentation 2)))
#+end_src

** Scala

Ensure that =scala-mode= and =sbt-mode= are installed.

#+begin_src emacs-lisp
  (use-package scala-mode
    :interpreter
    ("scala" . scala-mode))
  (use-package sbt-mode)
#+end_src

Don't show the startup message with launching ENSIME:

#+begin_src emacs-lisp
  (setq ensime-startup-notification nil)
#+end_src

Bind a few keys to common operations:

#+begin_src emacs-lisp
  (evil-define-key 'normal ensime-mode-map (kbd "C-t") 'ensime-type-at-point)
  (evil-define-key 'normal ensime-mode-map (kbd "M-.") 'ensime-edit-definition)
#+end_src

** =web-mode=

#+begin_src emacs-lisp
  (use-package web-mode)
#+end_src

If I'm in =web-mode=, I'd like to:

- Color color-related words with =rainbow-mode=.
- Still be able to run RSpec tests from =web-mode= buffers.
- Indent everything with 2 spaces.

#+begin_src emacs-lisp
  (add-hook 'web-mode-hook
            (lambda ()
              (rainbow-mode)
              (rspec-mode)
              (setq web-mode-markup-indent-offset 2)))
#+end_src

Use =web-mode= with embedded Ruby files, regular HTML, and PHP.

#+begin_src emacs-lisp
  (hrs/add-auto-mode
   'web-mode
   "\\.erb$"
   "\\.html$"
   "\\.php$"
   "\\.rhtml$")
#+end_src

** YAML

#+begin_src emacs-lisp
  (use-package yaml-mode)
#+end_src

If I'm editing YAML I'm usually in a Rails project. I'd like to be able to run
the tests from any buffer.

#+begin_src emacs-lisp
  (add-hook 'yaml-mode-hook 'rspec-mode)
#+end_src

* Terminal

I use =multi-term= to manage my shell sessions. It's bound to =C-c t=.

#+begin_src emacs-lisp
  (use-package multi-term)
  (global-set-key (kbd "C-c t") 'multi-term)
#+end_src

Use a login =bash= shell:

#+begin_src emacs-lisp
  (setq multi-term-program-switches "--login")
#+end_src

I'd rather not use Evil in the terminal. It's not especially useful (I don't use
vi bindings in xterm) and it shadows useful keybindings (=C-d= for EOF, for
example).

#+begin_src emacs-lisp
  (evil-set-initial-state 'term-mode 'emacs)
#+end_src

I add a bunch of hooks to =term-mode=:

- I'd like links (URLs, etc) to be clickable.
- Yanking in =term-mode= doesn't quite work. The text from the paste appears in
  the buffer but isn't sent to the shell process. This correctly binds =C-y= and
  middle-click to yank the way we'd expect.
- I bind =M-o= to quickly change windows. I'd like that in terminals, too.
- I don't want to perform =yasnippet= expansion when tab-completing.

#+begin_src emacs-lisp
  (defun hrs/term-paste (&optional string)
    (interactive)
    (process-send-string
     (get-buffer-process (current-buffer))
     (if string string (current-kill 0))))

  (add-hook 'term-mode-hook
            (lambda ()
              (goto-address-mode)
              (define-key term-raw-map (kbd "C-y") 'hrs/term-paste)
              (define-key term-raw-map (kbd "<mouse-2>") 'hrs/term-paste)
              (define-key term-raw-map (kbd "M-o") 'other-window)
              (setq yas-dont-activate t)))
#+end_src

* Publishing and task management with Org-mode

Including =org-tempo= restores the =<s=-style easy-templates that were
deprecated in Org 9.2.

I'd like to open =file:= links in Org with the applications defined in my
[[file:~/.dotfiles/email/.mailcap][mailcap]]. This clears the existing MIME mapping, parses my personal mailcap, and
tells Org to open those links with the mailcap-defined applications.

#+begin_src emacs-lisp
  (use-package org
    :ensure org-plus-contrib
    :config
    (require 'org-tempo)

    (add-hook 'org-mode-hook
              '(lambda ()
                 (setq mailcap-mime-data '())
                 (mailcap-parse-mailcap "~/.mailcap")
                 (setq org-file-apps
                       '((remote . emacs)
                         ("mobi" . "fbreader %s")
                         (system . mailcap)
                         (t . mailcap))))))
#+end_src

I'd like the initial scratch buffer to be in Org:

#+begin_src emacs-lisp
  (setq initial-major-mode 'org-mode)
#+end_src

** Display preferences

I like to see an outline of pretty bullets instead of a list of asterisks.

#+begin_src emacs-lisp
  (use-package org-bullets
    :init
    (add-hook 'org-mode-hook 'org-bullets-mode))
#+end_src

I like seeing a little downward-pointing arrow instead of the usual ellipsis
(=...=) that org displays when there's stuff under a header.

#+begin_src emacs-lisp
  (setq org-ellipsis "⤵")
#+end_src

Use syntax highlighting in source blocks while editing.

#+begin_src emacs-lisp
  (setq org-src-fontify-natively t)
#+end_src

Make TAB act as if it were issued in a buffer of the language's major mode.

#+begin_src emacs-lisp
  (setq org-src-tab-acts-natively t)
#+end_src

When editing a code snippet, use the current window rather than popping open a
new one (which shows the same information).

#+begin_src emacs-lisp
  (setq org-src-window-setup 'current-window)
#+end_src

Quickly insert a block of elisp:

#+begin_src emacs-lisp
  (add-to-list 'org-structure-template-alist
               '("el" . "src emacs-lisp"))
#+end_src

** Task and org-capture management

Store my org files in =~/documents/org=, maintain an inbox in Dropbox, define
the location of an index file (my main todo list), and archive finished tasks in
=~/documents/org/archive.org=.

#+begin_src emacs-lisp
  (setq org-directory "~/documents/org")

  (defun org-file-path (filename)
    "Return the absolute address of an org file, given its relative name."
    (concat (file-name-as-directory org-directory) filename))

  (setq org-inbox-file "~/sync/Dropbox/inbox.org")
  (setq org-index-file (org-file-path "index.org"))
  (setq org-archive-location
        (concat (org-file-path "archive.org") "::* From %s"))
#+end_src

I use [[http://agiletortoise.com/drafts/][Drafts]] to create new tasks, format them according to a template, and
append them to an "inbox.org" file in my Dropbox. This function lets me import
them easily from that inbox file to my index.

#+begin_src emacs-lisp
  (defun hrs/copy-tasks-from-inbox ()
    (when (file-exists-p org-inbox-file)
      (save-excursion
        (find-file org-index-file)
        (goto-char (point-max))
        (insert-file-contents org-inbox-file)
        (delete-file org-inbox-file))))
#+end_src

I store most of my personal tasks in my index and maintain a separate file for
work-related tasks, so I'd like to derive my agenda from those files.

I also keep some recurring events in, reasonably, a =recurring-events.org= file.
Those are (mostly) structured as =org-habit= items so they can recur according
to a schedule.

#+begin_src emacs-lisp
  (setq org-agenda-files (list org-index-file
                               (org-file-path "recurring-events.org")
                               (org-file-path "work.org")))
#+end_src

Hitting =C-c C-x C-s= will mark a todo as done and move it to an appropriate
place in the archive.

#+begin_src emacs-lisp
  (defun hrs/mark-done-and-archive ()
    "Mark the state of an org-mode item as DONE and archive it."
    (interactive)
    (org-todo 'done)
    (org-archive-subtree))

  (define-key org-mode-map (kbd "C-c C-x C-s") 'hrs/mark-done-and-archive)
#+end_src

Record the time that a todo was archived.

#+begin_src emacs-lisp
  (setq org-log-done 'time)
#+end_src

Ensure that a task can't be marked as done if it contains unfinished subtasks or
checklist items. This is handy for organizing "blocking" tasks hierarchically.

#+begin_src emacs-lisp
  (setq org-enforce-todo-dependencies t)
  (setq org-enforce-todo-checkbox-dependencies t)
#+end_src

Default to two weeks of agenda (instead of the default single week). Begin those
weeks /today/, not on the last Monday.

#+begin_src emacs-lisp
  (setq org-agenda-span 14)
  (setq org-agenda-start-on-weekday nil)
#+end_src

Hide the category prefix from tasks. In practice, I've usually only got one or
two files of tasks, so prefixing tasks with the file they're stored in is mostly
redundant.

#+begin_src emacs-lisp
  (setq org-agenda-prefix-format '((agenda . " %i %?-12t% s")
                                   (todo . " %i ")
                                   (tags . " %i ")
                                   (search . " %i ")))
#+end_src

I've got some custom agenda views that I use to visualize what I'm working on.

The "Personal agenda" view is a bit complicated; it displays:

1. The high-priority, actionable tasks (that is, the ones marked =[#A]= that
   aren't =BLOCKED= or =PENDING=),
2. My agenda for the next few days, including any recurring habits or scheduled
   events,
3. All the other, not-high-priority TODO items, and
4. All the PENDING tasks, which are awaiting a response from someone else but
   still require my attention (I might need to ping someone, say).

I effectively use the "A" priority to decide where I want to focus my attention
on a given day (I'll assign those priorities the night before, if I'm really on
top of things), so displaying them at the top makes sense.

A lot of this is based on [[https://blog.aaronbieber.com/2016/09/24/an-agenda-for-life-with-org-mode.html][Aaron Bieber's agenda configuration]], including the
=skip-subtree-if-priority= and =skip-subtree-if-habit= functions, which I've
shamelessly stolen and re-prefixed.

#+begin_src emacs-lisp
  (require 'org-habit)

  (defun hrs/org-skip-subtree-if-priority (priority)
    "Skip an agenda subtree if it has a priority of PRIORITY.

  PRIORITY may be one of the characters ?A, ?B, or ?C."
    (let ((subtree-end (save-excursion (org-end-of-subtree t)))
          (pri-value (* 1000 (- org-lowest-priority priority)))
          (pri-current (org-get-priority (thing-at-point 'line t))))
      (if (= pri-value pri-current)
          subtree-end
        nil)))

  (defun hrs/org-skip-subtree-if-habit ()
    "Skip an agenda entry if it has a STYLE property equal to \"habit\"."
    (let ((subtree-end (save-excursion (org-end-of-subtree t))))
      (if (string= (org-entry-get nil "STYLE") "habit")
          subtree-end
        nil)))

  (setq org-agenda-custom-commands
        '(("p" "Personal agenda"
           ((tags "PRIORITY=\"A\""
                  ((org-agenda-skip-function '(org-agenda-skip-entry-if
                                               'todo '("DONE" "PENDING" "BLOCKED")))
                   (org-agenda-overriding-header "Today's high-priority tasks:")))
            (agenda "")
            (todo "TODO"
                  ((org-agenda-skip-function '(or (hrs/org-skip-subtree-if-priority ?A)
                                                  (hrs/org-skip-subtree-if-habit)))
                   (org-agenda-overriding-header "Other tasks:")))
            (todo "PENDING"
                  ((org-agenda-skip-function '(hrs/org-skip-subtree-if-priority ?A))
                   (org-agenda-overriding-header "Waiting to hear about these:")))))))
#+end_src

I consult my agenda pretty often, so I bind =C-c d= to open it a it faster. This
also copies any files I've sent through Drafts into my index file before
displaying the index, so they'll be in the agenda view, too.

#+begin_src emacs-lisp
  (defun hrs/dashboard ()
    (interactive)
    (hrs/copy-tasks-from-inbox)
    (org-agenda nil "p"))

  (global-set-key (kbd "C-c d") 'hrs/dashboard)
#+end_src

**** Capturing tasks

Define a few common tasks as capture templates. Specifically, I frequently:

- Record ideas for future blog posts in =~/documents/notes/blog-ideas.org=,
- Maintain a todo list in =~/documents/org/index.org=.
- Convert emails into todos to maintain an empty inbox.

#+begin_src emacs-lisp
  (setq org-capture-templates
        '(("b" "Blog idea"
           entry
           (file "~/documents/notes/blog-ideas.org")
           "* %?\n")

          ("c" "Contact"
           entry
           (file "~/documents/contacts.org")
           "* %(org-contacts-template-name)
  :PROPERTIES:
  :ADDRESS: %^{123 Fake St., City, ST 12345}
  :PHONE: %^{555-555-5555}
  :EMAIL: %(org-contacts-template-email)
  :NOTE: %^{note}
  :END:")

          ("e" "Email" entry
           (file+headline org-index-file "Inbox")
           "* TODO %?\n\n%a\n\n")

          ("f" "Finished book"
           table-line (file "~/documents/notes/books-read.org")
           "| %^{Title} | %^{Author} | %u |")

          ("r" "Reading"
           checkitem
           (file (org-file-path "to-read.org")))

          ("s" "Subscribe to an RSS feed"
           plain
           (file "~/documents/rss-feeds.org")
           "*** [[%^{Feed URL}][%^{Feed name}]]")

          ("t" "Todo"
           entry
           (file+headline org-index-file "Inbox")
           "* TODO %?\n")))
#+end_src

When I'm starting an Org capture template I'd like to begin in insert mode. I'm
opening it up in order to start typing something, so this skips a step.

#+begin_src emacs-lisp
  (add-hook 'org-capture-mode-hook 'evil-insert-state)
#+end_src

Refiling according to the document's hierarchy.

#+begin_src emacs-lisp
  (setq org-refile-use-outline-path t)
  (setq org-outline-path-complete-in-steps nil)
#+end_src

**** Keybindings

Bind a few handy keys.

#+begin_src emacs-lisp
  (define-key global-map "\C-cl" 'org-store-link)
  (define-key global-map "\C-ca" 'org-agenda)
  (define-key global-map "\C-cc" 'org-capture)
#+end_src

Hit =C-c i= to quickly open up my todo list.

#+begin_src emacs-lisp
  (defun hrs/open-index-file ()
    "Open the master org TODO list."
    (interactive)
    (hrs/copy-tasks-from-inbox)
    (find-file org-index-file)
    (flycheck-mode -1)
    (end-of-buffer))

  (global-set-key (kbd "C-c i") 'hrs/open-index-file)
#+end_src

Hit =M-n= to quickly open up a capture template for a new todo.

#+begin_src emacs-lisp
  (defun org-capture-todo ()
    (interactive)
    (org-capture :keys "t"))

  (global-set-key (kbd "M-n") 'org-capture-todo)
  (add-hook 'gfm-mode-hook
            (lambda () (local-set-key (kbd "M-n") 'org-capture-todo)))
  (add-hook 'haskell-mode-hook
            (lambda () (local-set-key (kbd "M-n") 'org-capture-todo)))
#+end_src

** Exporting

Allow export to markdown and beamer (for presentations).

#+begin_src emacs-lisp
  (require 'ox-md)
  (require 'ox-beamer)
#+end_src

Allow =babel= to evaluate Emacs lisp, Ruby, dot, or Gnuplot code.

#+begin_src emacs-lisp
  (use-package gnuplot)

  (org-babel-do-load-languages
   'org-babel-load-languages
   '((emacs-lisp . t)
     (ruby . t)
     (dot . t)
     (gnuplot . t)))
#+end_src

Don't ask before evaluating code blocks.

#+begin_src emacs-lisp
  (setq org-confirm-babel-evaluate nil)
#+end_src

Use =htmlize= to ensure that exported code blocks use syntax highlighting.

#+begin_src emacs-lisp
  (use-package htmlize)
#+end_src

Associate the "dot" language with the =graphviz-dot= major mode.

#+begin_src emacs-lisp
  (use-package graphviz-dot-mode)
  (add-to-list 'org-src-lang-modes '("dot" . graphviz-dot))
#+end_src

Translate regular ol' straight quotes to typographically-correct curly quotes
when exporting.

#+begin_src emacs-lisp
  (setq org-export-with-smart-quotes t)
#+end_src

**** Exporting to HTML

Don't include a footer with my contact and publishing information at the bottom
of every exported HTML document.

#+begin_src emacs-lisp
  (setq org-html-postamble nil)
#+end_src

Exporting to HTML and opening the results triggers =/usr/bin/sensible-browser=,
which checks the =$BROWSER= environment variable to choose the right browser.
I'd like to always use Firefox, so:

#+begin_src emacs-lisp
  (setq browse-url-browser-function 'browse-url-generic
        browse-url-generic-program "firefox")

  (setenv "BROWSER" "firefox")
#+end_src

**** Exporting to PDF

I want to produce PDFs with syntax highlighting in the code. The best way to do
that seems to be with the =minted= package, but that package shells out to
=pygments= to do the actual work. =pdflatex= usually disallows shell commands;
this enables that.

#+begin_src emacs-lisp
  (setq org-latex-pdf-process
        '("xelatex -shell-escape -interaction nonstopmode -output-directory %o %f"
          "xelatex -shell-escape -interaction nonstopmode -output-directory %o %f"
          "xelatex -shell-escape -interaction nonstopmode -output-directory %o %f"))
#+end_src

Include the =minted= package in all of my LaTeX exports.

#+begin_src emacs-lisp
  (add-to-list 'org-latex-packages-alist '("" "minted"))
  (setq org-latex-listings 'minted)
#+end_src

**** Exporting projects

I have a few Org project definitions that I maintain in a separate elisp file.

#+begin_src emacs-lisp
  (load-file ".emacs.d/projects.el")
#+end_src

** TeX configuration

I rarely write LaTeX directly any more, but I often export through it with
org-mode, so I'm keeping them together.

Automatically parse the file after loading it.

#+begin_src emacs-lisp
  (setq TeX-parse-self t)
#+end_src

Always use =pdflatex= when compiling LaTeX documents. I don't really have any
use for DVIs.

#+begin_src emacs-lisp
  (setq TeX-PDF-mode t)
#+end_src

Enable a minor mode for dealing with math (it adds a few useful keybindings),
and always treat the current file as the "main" file. That's intentional, since
I'm usually actually in an org document.

#+begin_src emacs-lisp
  (add-hook 'LaTeX-mode-hook
            (lambda ()
              (LaTeX-math-mode)
              (setq TeX-master t)))
#+end_src

** Add links to Instapaper

I sometimes use [[https://instapaper.com][Instapaper]] to store articles I want to read later. The
=instapaper.el= library sends my URLs there.

#+begin_src emacs-lisp
  (use-package instapaper)
  (require 'instapaper)

  (setq instapaper-username (netrc-username "instapaper.com")
        instapaper-password (netrc-password "instapaper.com"))
#+end_src

* Blogging

I maintain a blog written in Jekyll. There are plenty of command-line tools to
automate creating a new post, but staying in my editor minimizes friction and
encourages me to write.

This defines a =hrs/new-blog-post= function, which prompts the user for a title
and creates a new draft (with a slugged file name) in the blog's =_drafts/=
directory. The new post includes appropriate YAML header information.

This also defines =hrs/publish-post= and =hrs/unpublish-post=, which adjust the
date in the YAML front matter and rename the file appropriately.

#+begin_src emacs-lisp
  (defvar hrs/jekyll-drafts-directory "/home/hrs/documents/blog/_drafts/")
  (defvar hrs/jekyll-posts-directory "/home/hrs/documents/blog/_posts/")
  (defvar hrs/jekyll-post-extension ".md")

  (defun hrs/timestamp ()
    (format-time-string "%Y-%m-%d"))

  (defun hrs/replace-whitespace-with-hyphens (s)
    (replace-regexp-in-string " " "-" s))

  (defun hrs/replace-nonalphanumeric-with-whitespace (s)
    (replace-regexp-in-string "[^A-Za-z0-9 ]" " " s))

  (defun hrs/remove-quotes (s)
    (replace-regexp-in-string "[\'\"]" "" s))

  (defun hrs/replace-unusual-characters (title)
    "Remove quotes, downcase everything, and replace characters
  that aren't alphanumeric with hyphens."
    (hrs/replace-whitespace-with-hyphens
     (s-trim
      (downcase
       (hrs/replace-nonalphanumeric-with-whitespace
        (hrs/remove-quotes title))))))

  (defun hrs/slug-for (title)
    "Given a blog post title, return a convenient URL slug.
     Downcase letters and remove special characters."
    (let ((slug (hrs/replace-unusual-characters title)))
      (while (string-match "--" slug)
        (setq slug (replace-regexp-in-string "--" "-" slug)))
      slug))

  (defun hrs/jekyll-yaml-template (title)
    "Return the YAML header information appropriate for a blog
     post. Include the title, the current date, the post layout,
     and an empty list of tags."
    (concat
     "---\n"
     "title: " title "\n"
     "date:\n"
     "layout: post\n"
     "# pdf_file: " (hrs/slug-for title) ".pdf\n"
     "tags: []\n"
     "---\n\n"))

  (defun hrs/new-blog-post (title)
    "Create a new blog draft in Jekyll."
    (interactive "sPost title: ")
    (let ((post (concat hrs/jekyll-drafts-directory
                        (hrs/slug-for title)
                        hrs/jekyll-post-extension)))
      (if (file-exists-p post)
          (find-file post)
        (find-file post)
        (insert (hrs/jekyll-yaml-template title)))))

  (defun hrs/jekyll-draft-p ()
    "Return true if the current buffer is a draft."
    (equal
     (file-name-directory (buffer-file-name (current-buffer)))
     hrs/jekyll-drafts-directory))

  (defun hrs/jekyll-published-p ()
    "Return true if the current buffer is a published post."
    (equal
     (file-name-directory (buffer-file-name (current-buffer)))
     hrs/jekyll-posts-directory))

  (defun hrs/publish-post ()
    "Move a draft post to the posts directory, rename it to include
  the date, reopen the new file, and insert the date in the YAML
  front matter."
    (interactive)
    (cond ((not (hrs/jekyll-draft-p))
           (message "This is not a draft post."))
          ((buffer-modified-p)
           (message "Can't publish post; buffer has modifications."))
          (t
           (let ((filename
                  (concat hrs/jekyll-posts-directory
                          (hrs/timestamp) "-"
                          (file-name-nondirectory
                           (buffer-file-name (current-buffer)))))
                 (old-point (point)))
             (rename-file (buffer-file-name (current-buffer))
                          filename)
             (kill-buffer nil)
             (find-file filename)
             (set-window-point (selected-window) old-point)
             (save-excursion
               (beginning-of-buffer)
               (replace-regexp "^date:$" (concat "date: " (hrs/timestamp))))
             (save-buffer)
             (message "Published post!")))))

  (defun hrs/unpublish-post ()
    "Move a published post to the drafts directory, rename it to
  exclude the date, reopen the new file, and remove the date in the
  YAML front matter."
    (interactive)
    (cond ((not (hrs/jekyll-published-p))
           (message "This is not a published post."))
          ((buffer-modified-p)
           (message "Can't publish post; buffer has modifications."))
          (t
           (let ((filename
                  (concat hrs/jekyll-drafts-directory
                          (substring
                           (file-name-nondirectory
                            (buffer-file-name (current-buffer)))
                           11 nil)))
                 (old-point (point)))
             (rename-file (buffer-file-name (current-buffer))
                          filename)
             (kill-buffer nil)
             (find-file filename)
             (set-window-point (selected-window) old-point)
             (save-excursion
               (beginning-of-buffer)
               (replace-regexp "^date: [0-9][0-9][0-9][0-9]-[0-9][0-9]-[0-9][0-9]$" "date:"))
             (save-buffer)
             (message "Returned post to drafts!")))))
#+end_src

This selects and inserts a tag:

#+begin_src emacs-lisp
  (defun hrs/existing-blog-tags ()
    "Return a list of all the tags currently used in my blog."
    (split-string (shell-command-to-string "cd ~/documents/blog && rake tags")))

  (defun hrs/insert-blog-tag ()
    "Prompt for one of the existing tags used in the blog and
  insert it in the YAML front matter appropriately."
    (interactive)
    (save-excursion
      (beginning-of-buffer)
      (search-forward-regexp "^tags: \\[")
      (insert
       (ivy-completing-read "Insert tag: " (hrs/existing-blog-tags))
       (if (looking-at "\\]") "" ", ")))
    (message "Tagged!"))
#+end_src

* Email with =mu4e=

Use the =evil= bindings for navigation. They're very similar to the =mutt=
bindings, which matches my muscle memory nicely. =)

#+begin_src emacs-lisp
  (use-package evil-mu4e)
  (require 'evil-mu4e)
#+end_src

** Where's my mail? Who am I?

I keep my mail in =~/.mail=. The default maildir would be =~/Maildir=, but I'd
rather hide it; I don't poke around in there manually very often.

This setting matches the paths in my =mbsync= configuration.

#+begin_src emacs-lisp
  (setq mu4e-maildir "~/.mail")
#+end_src

I only have one context at the moment. If I had another email account, though,
I'd define it in here with an additional =make-mu4e-context= block.

My full name is defined earlier in this configuration file.

#+begin_src emacs-lisp
  (setq mu4e-contexts
        `(,(make-mu4e-context
            :name "personal"
            :match-func (lambda (msg)
                          (when msg
                            (string-prefix-p "/personal" (mu4e-message-field msg :maildir))))
            :vars '((user-mail-address . "hello@harryrschwartz.com")
                    (mu4e-trash-folder . "/personal/archive")
                    (mu4e-refile-folder . "/personal/archive")
                    (mu4e-sent-folder . "/personal/sent")
                    (mu4e-drafts-folder . "/personal/drafts")))))
#+end_src

** Fetching new mail

I fetch my email with a [[file:~/.dotfiles/bash/.bin/get-new-mail][custom script]] (though, in practice, this is never
called; I have a cron job regularly calling the script to fetch my mail
asynchronously).

#+begin_src emacs-lisp
  (setq mu4e-get-mail-command "~/.bin/get-new-mail")
#+end_src

Rename files when moving them between directories. =mbsync= supposedly prefers
this; I'm cargo-culting.

#+begin_src emacs-lisp
  (setq mu4e-change-filenames-when-moving t)
#+end_src

** Viewing mail

I check my email pretty often! Probably more than I should. This binds =C-c m=
to close any other windows and open my personal inbox.

#+begin_src emacs-lisp
  (defun hrs/visit-inbox ()
    (interactive)
    (mu4e~headers-jump-to-maildir "/personal/inbox"))

  (global-set-key (kbd "C-c m") 'hrs/visit-inbox)
#+end_src

I don't really need to see the =*mu4e-main*= buffer (or, really, more than one
mu4e buffer of any kind at a time).

#+begin_src emacs-lisp
  (setq mu4e-split-view 'single-window)
#+end_src

I don't need to see the context of a thread (with all the deleted messages) in
my inbox.

#+begin_src emacs-lisp
  (setq mu4e-headers-include-related nil)
#+end_src

=mu4e= starts approximately instantaneously, so I don't know why I'd want to
reconsider quitting it.

#+begin_src emacs-lisp
  (setq mu4e-confirm-quit nil)
#+end_src

** Composing a new message

When I'm composing a new email, default to using the first context.

#+begin_src emacs-lisp
  (setq mu4e-compose-context-policy 'pick-first)
#+end_src

Compose new messages (as with =C-x m=) using =mu4e-user-agent=.

#+begin_src emacs-lisp
  (setq mail-user-agent 'mu4e-user-agent)
#+end_src

Enable Org-style tables and list manipulation.

#+begin_src emacs-lisp
  (add-hook 'message-mode-hook 'turn-on-orgtbl)
  (add-hook 'message-mode-hook 'turn-on-orgstruct++)
#+end_src

Once I've sent an email, kill the associated buffer instead of just burying it.

#+begin_src emacs-lisp
  (setq message-kill-buffer-on-exit t)
#+end_src

** Reading an email

Display the sender's email address along with their name.

#+begin_src emacs-lisp
  (setq mu4e-view-show-addresses t)
#+end_src

Save attachments in my =~/downloads= directory, not my home directory.

#+begin_src emacs-lisp
  (setq mu4e-attachment-dir "~/downloads")
#+end_src

Hit =C-c C-o= to open a URL in the browser.

#+begin_src emacs-lisp
  (define-key mu4e-view-mode-map (kbd "C-c C-o") 'mu4e~view-browse-url-from-binding)
#+end_src

While HTML emails are just fundamentally awful, we usually still need to read
them. This ensures that their formatting in Emacs isn't too hideous:

#+begin_src emacs-lisp
  (require 'mu4e-contrib)
  (setq mu4e-html2text-command 'mu4e-shr2text
        shr-color-visible-luminance-min 60
        shr-color-visible-distance-min 5
        shr-use-fonts nil
        shr-use-colors nil)
  (advice-add #'shr-colorize-region
              :around (defun shr-no-colourise-region (&rest ignore)))
#+end_src

But some HTML emails are just too messy to display in Emacs. This binds =a h= to
open the current email in my default Web browser.

#+begin_src emacs-lisp
  (add-to-list 'mu4e-view-actions
               '("html in browser" . mu4e-action-view-in-browser)
               t)
#+end_src

** Encryption

If a message is encrypted, my reply should always be encrypted, too.

#+begin_src emacs-lisp
  (defun hrs/encrypt-responses ()
    "Encrypt the current message if it's a reply to another encrypted message."
    (let ((msg mu4e-compose-parent-message))
      (when (and msg (member 'encrypted (mu4e-message-field msg :flags)))
          (mml-secure-message-encrypt-pgpmime))))

  (add-hook 'mu4e-compose-mode-hook 'hrs/encrypt-responses)
#+end_src

** Sending mail over SMTP

I send my email through =msmtp=. These settings describe how to send a message:

- Use a sendmail program instead of sending directly from Emacs,
- Tell =msmtp= to infer the correct account from the =From:= address,
- Don't add a "=-f username=" flag to the =msmtp= command, and
- Use =/usr/bin/msmtp=!

#+begin_src emacs-lisp
  (setq message-send-mail-function 'message-send-mail-with-sendmail)
  (setq message-sendmail-extra-arguments '("--read-envelope-from"))
  (setq message-sendmail-f-is-evil 't)
  (setq sendmail-program "msmtp")
#+end_src

** Org integration

=org-mu4e= lets me store links to emails. I use this to reference emails in my
TODO list while keeping my inbox empty.

#+begin_src emacs-lisp
  (require 'org-mu4e)
#+end_src

When storing a link to a message in the headers view, link to the message
instead of the search that resulted in that view.

#+begin_src emacs-lisp
  (setq org-mu4e-link-query-in-headers-mode nil)
#+end_src

** Configure =org-contacts= with =mu4e=

Use an =org-contacts= file to manage my address book.

 #+begin_src emacs-lisp
   (use-package org-contacts
     :ensure nil
     :after org
     :custom (org-contacts-files '("~/documents/contacts.org")))

  (setq mu4e-org-contacts-file (car org-contacts-files))
  (add-to-list 'mu4e-headers-actions
    '("org-contact-add" . mu4e-action-add-org-contact) t)
  (add-to-list 'mu4e-view-actions
    '("org-contact-add" . mu4e-action-add-org-contact) t)
 #+end_src

* RSS with =elfeed=

Install elfeed and load up my feeds.

#+begin_src emacs-lisp
  (use-package elfeed
    :config
    (elfeed-set-max-connections 32))
  (use-package elfeed-org
    :config
    (progn
      (elfeed-org)
      (setq rmh-elfeed-org-files (list "~/documents/rss-feeds.org"))))
#+end_src

Sort RSS feeds first by tag (=comics= come before =haskell=, for example), then
by name of the feed, and finally by publication date.

#+begin_src emacs-lisp
  (defun hrs/custom-elfeed-sort (a b)
    (let* ((a-tags (format "%s" (elfeed-entry-tags a)))
           (b-tags (format "%s" (elfeed-entry-tags b)))
           (a-title (elfeed-feed-title (elfeed-entry-feed a)))
           (b-title (elfeed-feed-title (elfeed-entry-feed b))))
      (if (string= a-tags b-tags)
          (if (string= a-title b-title)
              (< (elfeed-entry-date b) (elfeed-entry-date a))
            (string< b-title a-title))
        (string< a-tags b-tags))))

  (setf elfeed-search-sort-function #'hrs/custom-elfeed-sort)
#+end_src

Open =elfeed= with =C-c r=:

#+begin_src emacs-lisp
  (global-set-key (kbd "C-c r") 'elfeed)
#+end_src

Use =o= to browse the entry in a Web browser.

#+begin_src emacs-lisp
  (add-to-list 'evil-emacs-state-modes 'elfeed-show-mode)
  (add-to-list 'evil-emacs-state-modes 'elfeed-search-mode)

  (evil-add-hjkl-bindings elfeed-search-mode-map)
  (evil-add-hjkl-bindings elfeed-show-mode-map)

  (define-key elfeed-show-mode-map "o" 'elfeed-show-visit)
  (define-key elfeed-search-mode-map "o" 'elfeed-search-browse-url)
#+end_src

Some external integrations need access to the current entry at point:

#+begin_src emacs-lisp
  (defun hrs/elfeed-current-entry ()
    (cond ((eq major-mode 'elfeed-show-mode)
           elfeed-show-entry)
          ((eq major-mode 'elfeed-search-mode)
           (elfeed-search-selected t))))
#+end_src

** Add links to Pinboard

I store some articles on [[https://pinboard.in/][Pinboard]]. The =pinboard.el= library handles that.

I bind =a= (for "archive," let's say) to send the current entry to Pinboard.

#+begin_src emacs-lisp
    (use-package pinboard)

    (defun hrs/elfeed-pinboard-current-entry ()
      (interactive)
      (let ((url (elfeed-entry-link (hrs/elfeed-current-entry)))
            (title (elfeed-entry-title (hrs/elfeed-current-entry))))
        (pinboard-auth)
        (pinboard-not-too-soon :pinboard-save
          (pinboard-save url title "" "" t nil))))

    (define-key elfeed-show-mode-map "a" 'hrs/elfeed-pinboard-current-entry)
    (define-key elfeed-search-mode-map "a" 'hrs/elfeed-pinboard-current-entry)
#+end_src

** Add links to Instapaper

I sometimes use [[https://instapaper.com][Instapaper]] to store articles I want to read later. The
=instapaper.el= library sends my URLs there.

#+begin_src emacs-lisp
  (use-package instapaper)
  (require 'instapaper)

  (setq instapaper-username (netrc-username "instapaper.com")
        instapaper-password (netrc-password "instapaper.com"))
#+end_src

Use =i= to send the current entry to Instapaper.

#+begin_src emacs-lisp
  (defun hrs/elfeed-instapaper-entry (entry)
    (let ((url (elfeed-entry-link entry))
          (title (elfeed-entry-title entry)))
      (instapaper-add url title)))

  (defun hrs/elfeed-instapaper-current-entry ()
    (interactive)
    (hrs/elfeed-instapaper-entry (hrs/elfeed-current-entry)))

  (define-key elfeed-show-mode-map "i" 'hrs/elfeed-instapaper-current-entry)
  (define-key elfeed-search-mode-map "i" 'hrs/elfeed-instapaper-current-entry)
#+end_src

* Music through =mpd= via =emms=

I've recently started using EMMS as my music interface. The heavy lifting is
handled by the =mpd= daemon (configured elsewhere).

#+begin_src emacs-lisp
  (use-package emms
    :config
    (require 'emms-setup)
    (require 'emms-player-mpd)
    (emms-all))
#+end_src

Use =mpd= as both the music player and the source of track information.

#+begin_src emacs-lisp
  (setq emms-player-list '(emms-player-mpd))
  (setq emms-info-functions '(emms-info-mpd))
#+end_src

Bind an appropriate set of =evil= keys.

#+begin_src emacs-lisp
  (evil-collection-emms-setup)
  (evil-collection-emms-browser-setup)
#+end_src

Seek forward and backward by 5 seconds (instead of the default of 10).

#+begin_src emacs-lisp
  (setq emms-seek-seconds 5)
#+end_src

Don't change the size of my fonts! Sheesh. How many times do I need to tell you,
packages? =)

#+begin_src emacs-lisp
  (set-face-attribute 'emms-browser-artist-face nil :height 1.0)
  (set-face-attribute 'emms-browser-album-face nil :height 1.0)
  (set-face-attribute 'emms-browser-track-face nil :height 1.0)
#+end_src

Bind =C-c b= to summon the EMMS browser and current playlist.

#+begin_src emacs-lisp
  (defun hrs/music-browser ()
    (interactive)
    (delete-other-windows)
    (emms-smart-browse))

  (global-set-key (kbd "C-c b") 'hrs/music-browser)
#+end_src

Display a system notification when a new song plays, or if a song is
played or paused.

#+begin_src emacs-lisp
  (defun hrs/music-current-album ()
    (cdr (assoc 'info-album
                (emms-playlist-current-selected-track))))

  (defun hrs/music-current-artist ()
    (cdr (assoc 'info-artist
                (emms-playlist-current-selected-track))))

  (defun hrs/music-current-title ()
    (cdr (assoc 'info-title
                (emms-playlist-current-selected-track))))

  (defun hrs/entity-escape (string)
    (s-replace-all '(("&" . "&amp;") ("<" . "&lt;") (">" "&gt;")) string))

  (defun hrs/music-notification-message (album artist)
    "Format a nice notification message about the current song.
  Include the album if it's non-nil. Escape some entities in the
  message, since Pango (?) can't seem to parse them."
    (if album
        (concat "by: <i>" (hrs/entity-escape artist) "</i>\n"
                "from: <i>" (hrs/entity-escape album) "</i>")
      (concat "by: <i>" (hrs/entity-escape artist) "</i>")))

  (defun hrs/notify-current-song ()
    (let* ((album (hrs/music-current-album))
           (artist (hrs/music-current-artist))
           (title (hrs/music-current-title))
           (message (hrs/music-notification-message album artist)))
      (hrs/notify-send title message)))

  (add-hook 'emms-player-started-hook '(lambda () (hrs/notify-current-song)))
#+end_src

* Writing prose

** Enable spell-checking in the usual places

I want to make sure that I've enabled spell-checking if I'm editing text,
composing an email, or authoring a Git commit.

#+begin_src emacs-lisp
  (use-package flyspell
    :config
    (add-hook 'text-mode-hook 'turn-on-auto-fill)
    (add-hook 'gfm-mode-hook 'flyspell-mode)
    (add-hook 'org-mode-hook 'flyspell-mode)

    (add-hook 'git-commit-mode-hook 'flyspell-mode)
    (add-hook 'mu4e-compose-mode-hook 'flyspell-mode))
#+end_src

** Look up definitions in Webster 1913

I look up definitions by hitting =C-x w=, which shells out to =sdcv=. I've
loaded that with the (beautifully lyrical) 1913 edition of Webster's dictionary,
so these definitions are a lot of fun.

#+begin_src emacs-lisp
  (defun hrs/dictionary-prompt ()
    (read-string
     (format "Word (%s): " (or (hrs/region-or-word) ""))
     nil
     nil
     (hrs/region-or-word)))

  (defun hrs/dictionary-define-word ()
    (interactive)
    (let* ((word (hrs/dictionary-prompt))
           (buffer-name (concat "Definition: " word)))
      (with-output-to-temp-buffer buffer-name
        (shell-command (format "sdcv -n %s" word) buffer-name))))

  (define-key global-map (kbd "C-x w") 'hrs/dictionary-define-word)
#+end_src

** Look up words in a thesaurus

Hitting =C-x s= searches for synonyms for the word at point.

#+begin_src emacs-lisp
  (use-package powerthesaurus
    :bind
    ("C-x s" . powerthesaurus-lookup-word-dwim))
#+end_src

** Editing with Markdown

Because I can't always use =org=.

- Associate =.md= files with GitHub-flavored Markdown.
- Use =pandoc= to render the results.
- Leave the code block font unchanged.

#+begin_src emacs-lisp
  (use-package markdown-mode
    :commands gfm-mode

    :mode (("\\.md$" . gfm-mode))

    :config
    (setq markdown-command "pandoc --standalone --mathjax --from=markdown")
    (custom-set-faces
     '(markdown-code-face ((t nil)))))
#+end_src

** Wrap paragraphs automatically

=AutoFillMode= automatically wraps paragraphs, kinda like hitting =M-q=. I wrap
a lot of paragraphs, so this automatically wraps 'em when I'm writing text,
Markdown, or Org.

#+begin_src emacs-lisp
  (add-hook 'text-mode-hook 'auto-fill-mode)
  (add-hook 'gfm-mode-hook 'auto-fill-mode)
  (add-hook 'org-mode-hook 'auto-fill-mode)
#+end_src

** Cycle between spacing alternatives

Successive calls to =cycle-spacing= rotate between changing the whitespace
around point to:

- A single space,
- No spaces, or
- The original spacing.

Binding this to =M-SPC= is strictly better than the original binding of
=just-one-space=.

#+begin_src emacs-lisp
  (global-set-key (kbd "M-SPC") 'cycle-spacing)
#+end_src

** Linting prose

I use [[http://proselint.com/][proselint]] to check my prose for common errors. This creates a flycheck
checker that runs proselint in texty buffers and displays my errors.

#+begin_src emacs-lisp
  (require 'flycheck)

  (flycheck-define-checker proselint
    "A linter for prose."
    :command ("proselint" source-inplace)
    :error-patterns
    ((warning line-start (file-name) ":" line ":" column ": "
              (id (one-or-more (not (any " "))))
              (message (one-or-more not-newline)
                       (zero-or-more "\n" (any " ") (one-or-more not-newline)))
              line-end))
    :modes (text-mode markdown-mode gfm-mode org-mode))

  (add-to-list 'flycheck-checkers 'proselint)
#+end_src

Use flycheck in the appropriate buffers:

#+begin_src emacs-lisp
  (add-hook 'markdown-mode-hook #'flycheck-mode)
  (add-hook 'gfm-mode-hook #'flycheck-mode)
  (add-hook 'text-mode-hook #'flycheck-mode)
  (add-hook 'org-mode-hook #'flycheck-mode)
#+end_src

** Enable region case modification

#+begin_src emacs-lisp
  (put 'downcase-region 'disabled nil)
  (put 'upcase-region 'disabled nil)
#+end_src

** Quickly explore my "notes" directory with =deft=

#+begin_src emacs-lisp
  (use-package deft
    :bind ("C-c n" . deft)
    :commands (deft)
    :config

    (setq deft-directory "~/documents/notes"
          deft-recursive t
          deft-use-filename-as-title t)

    (evil-set-initial-state 'deft-mode 'emacs))
#+end_src

* File management with =dired=

Hide dotfiles by default, but toggle their visibility with =.=.

#+begin_src emacs-lisp
  (use-package dired-hide-dotfiles
    :config
    (dired-hide-dotfiles-mode)
    (define-key dired-mode-map "." 'dired-hide-dotfiles-mode))
#+end_src

Open media with the appropriate programs.

#+begin_src emacs-lisp
  (use-package dired-open
    :config
    (setq dired-open-extensions
          '(("avi" . "mpv")
            ("cbr" . "comix")
            ("doc" . "abiword")
            ("docx" . "abiword")
            ("gif" . "ffplay")
            ("gnumeric" . "gnumeric")
            ("html" . "firefox")
            ("jpeg" . "s")
            ("jpg" . "s")
            ("mkv" . "mpv")
            ("mov" . "mpv")
            ("mp3" . "mpv")
            ("mp4" . "mpv")
            ("pdf" . "zathura")
            ("png" . "s")
            ("webm" . "mpv")
            ("xls" . "gnumeric")
            ("xlsx" . "gnumeric"))))
#+end_src

These are the switches that get passed to =ls= when =dired= gets a list of
files. We're using:

- =l=: Use the long listing format.
- =h=: Use human-readable sizes.
- =v=: Sort numbers naturally.
- =A=: Almost all. Doesn't include "=.=" or "=..=".

That said, I'd usually like to hide those extra details.
=dired-hide-details-mode= can be toggled with =(=.

#+begin_src emacs-lisp
  (setq-default dired-listing-switches "-lhvA")
  (add-hook 'dired-mode-hook (lambda () (dired-hide-details-mode 1)))
#+end_src

Set up DWIM ("do what I mean") for =dired=. When I've got two =dired= windows
side-by-side, and I move or copy files in one window, this sets the default
location to the other window.

#+begin_src emacs-lisp
  (setq dired-dwim-target t)
#+end_src

Kill buffers of files/directories that are deleted in =dired=.

#+begin_src emacs-lisp
  (setq dired-clean-up-buffers-too t)
#+end_src

Always copy directories recursively instead of asking every time.

#+begin_src emacs-lisp
  (setq dired-recursive-copies 'always)
#+end_src

Ask before recursively /deleting/ a directory, though.

#+begin_src emacs-lisp
  (setq dired-recursive-deletes 'top)
#+end_src

Files are normally moved and copied synchronously. This is fine for small or
local files, but copying a large file or moving a file across a mounted network
drive blocks Emacs until the process is completed. Unacceptable!

This uses =emacs-async= to make =dired= perform actions asynchronously.

#+begin_src emacs-lisp
  (use-package async
    :config
    (dired-async-mode 1))
#+end_src

Use "j" and "k" to move around in =dired=.

#+begin_src emacs-lisp
  (evil-define-key 'normal dired-mode-map (kbd "j") 'dired-next-line)
  (evil-define-key 'normal dired-mode-map (kbd "k") 'dired-previous-line)
#+end_src

I'm often browsing directories of photos and images, so this binds "v" to view a
slideshow of the current directory with =s= (a custom =feh= wrapper defined
elsewhere in this repo).

#+begin_src emacs-lisp
  (defun hrs/dired-slideshow ()
    (interactive)
    (start-process "dired-slideshow" nil "s" (dired-current-directory)))

  (evil-define-key 'normal dired-mode-map (kbd "v") 'hrs/dired-slideshow)
#+end_src

* Editing settings

** Quickly visit Emacs configuration

I futz around with my dotfiles a lot. This binds =C-c e= to quickly open my
Emacs configuration file.

#+begin_src emacs-lisp
  (defun hrs/visit-emacs-config ()
    (interactive)
    (find-file "~/.emacs.d/configuration.org"))

  (global-set-key (kbd "C-c e") 'hrs/visit-emacs-config)
#+end_src

** Always kill current buffer

Assume that I always want to kill the current buffer when hitting =C-x k=.

#+begin_src emacs-lisp
  (global-set-key (kbd "C-x k") 'hrs/kill-current-buffer)
#+end_src

** Set up =helpful=

The =helpful= package provides, among other things, more context in Help
buffers.

#+begin_src emacs-lisp
  (use-package helpful)

  (global-set-key (kbd "C-h f") #'helpful-callable)
  (global-set-key (kbd "C-h v") #'helpful-variable)
  (global-set-key (kbd "C-h k") #'helpful-key)
  (evil-define-key 'normal helpful-mode-map (kbd "q") 'quit-window)
#+end_src

** Look for executables in =/usr/local/bin=

#+begin_src emacs-lisp
  (hrs/append-to-path "/usr/local/bin")
#+end_src

** Save my location within a file

Using =save-place-mode= saves the location of point for every file I visit. If I
close the file or close the editor, then later re-open it, point will be at the
last place I visited.

#+begin_src emacs-lisp
  (save-place-mode t)
#+end_src

** Always indent with spaces

Never use tabs. Tabs are the devil’s whitespace.

#+begin_src emacs-lisp
  (setq-default indent-tabs-mode nil)
#+end_src

** Install and configure =which-key=

=which-key= displays the possible completions for a long keybinding. That's
really helpful for some modes (like =projectile=, for example).

#+begin_src emacs-lisp
  (use-package which-key
    :config (which-key-mode))
#+end_src

** Configure =yasnippet=

#+begin_src emacs-lisp
  (use-package yasnippet)
#+end_src

I keep my snippets in =~/.emacs/snippets/text-mode=, and I always want =yasnippet=
enabled.

#+begin_src emacs-lisp
  (setq yas-snippet-dirs '("~/.emacs.d/snippets/text-mode"))
  (yas-global-mode 1)
#+end_src

I /don’t/ want =yas= to automatically indent the snippets it inserts. Sometimes
this looks pretty bad (when indenting org-mode, for example, or trying to guess
at the correct indentation for Python).

#+begin_src emacs-lisp
  (setq yas-indent-line 'auto)
#+end_src

** Configure =ivy= and =counsel=

I use =ivy= and =counsel= as my completion framework.

This configuration:

- Uses =counsel-M-x= for command completion,
- Replaces =isearch= with =swiper=,
- Uses =smex= to maintain history,
- Enables fuzzy matching everywhere except swiper (where it's thoroughly
  unhelpful), and
- Includes recent files in the switch buffer.

#+begin_src emacs-lisp
  (use-package counsel
    :bind
    ("M-x" . 'counsel-M-x)
    ("C-s" . 'swiper)

    :config
    (use-package flx)
    (use-package smex)

    (ivy-mode 1)
    (setq ivy-use-virtual-buffers t)
    (setq ivy-count-format "(%d/%d) ")
    (setq ivy-initial-inputs-alist nil)
    (setq ivy-re-builders-alist
          '((swiper . ivy--regex-plus)
            (t . ivy--regex-fuzzy))))
#+end_src

** Switch and rebalance windows when splitting

When splitting a window, I invariably want to switch to the new window. This
makes that automatic.

#+begin_src emacs-lisp
  (defun hrs/split-window-below-and-switch ()
    "Split the window horizontally, then switch to the new pane."
    (interactive)
    (split-window-below)
    (balance-windows)
    (other-window 1))

  (defun hrs/split-window-right-and-switch ()
    "Split the window vertically, then switch to the new pane."
    (interactive)
    (split-window-right)
    (balance-windows)
    (other-window 1))

  (global-set-key (kbd "C-x 2") 'hrs/split-window-below-and-switch)
  (global-set-key (kbd "C-x 3") 'hrs/split-window-right-and-switch)
#+end_src

** Mass editing of =grep= results

I like the idea of mass editing =grep= results the same way I can edit filenames
in =dired=. These keybindings allow me to use =C-x C-q= to start editing =grep=
results and =C-c C-c= to stop, just like in =dired=.

#+begin_src emacs-lisp
  (use-package wgrep)

  (eval-after-load 'grep
    '(define-key grep-mode-map
      (kbd "C-x C-q") 'wgrep-change-to-wgrep-mode))

  (eval-after-load 'wgrep
    '(define-key grep-mode-map
      (kbd "C-c C-c") 'wgrep-finish-edit))

  (setq wgrep-auto-save-buffer t)
#+end_src

** Use projectile everywhere

#+begin_src emacs-lisp
  (projectile-global-mode)
#+end_src

** Add a bunch of engines for =engine-mode=

Enable [[https://github.com/hrs/engine-mode][engine-mode]] and define a few useful engines.

#+begin_src emacs-lisp
  (use-package engine-mode)
  (require 'engine-mode)

  (defengine duckduckgo
    "https://duckduckgo.com/?q=%s"
    :keybinding "d")

  (defengine github
    "https://github.com/search?ref=simplesearch&q=%s"
    :keybinding "g")

  (defengine google
    "http://www.google.com/search?ie=utf-8&oe=utf-8&q=%s")

  (defengine rfcs
    "http://pretty-rfc.herokuapp.com/search?q=%s")

  (defengine stack-overflow
    "https://stackoverflow.com/search?q=%s"
    :keybinding "s")

  (defengine wikipedia
    "http://www.wikipedia.org/search-redirect.php?language=en&go=Go&search=%s"
    :keybinding "w")

  (defengine wiktionary
    "https://www.wikipedia.org/search-redirect.php?family=wiktionary&language=en&go=Go&search=%s")

  (defengine youtube
    "https://www.youtube.com/results?search_query=%s")

  (engine-mode t)
#+end_src

* Set custom keybindings

Just a few handy functions.

#+begin_src emacs-lisp
  (global-set-key (kbd "C-w") 'backward-kill-word)
  (global-set-key (kbd "M-o") 'other-window)
#+end_src

Remap when working in terminal Emacs.

#+begin_src emacs-lisp
  (define-key input-decode-map "\e[1;2A" [S-up])
#+end_src
* Extra

#+begin_src emacs-lisp
  (load-file "~/.emacs-private.el")
#+end_src
